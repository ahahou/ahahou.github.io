<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>从零开始</title>
  
  <subtitle>叶子( •̀ ω •́ )y</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangyibo.top/"/>
  <updated>2020-02-06T07:17:46.968Z</updated>
  <id>http://wangyibo.top/</id>
  
  <author>
    <name>wangyibo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TensorFlow</title>
    <link href="http://wangyibo.top/2020/02/05/TensorFlow/"/>
    <id>http://wangyibo.top/2020/02/05/TensorFlow/</id>
    <published>2020-02-05T08:50:14.000Z</published>
    <updated>2020-02-06T07:17:46.968Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述TensorFLow1的组成单元于基本思想，同时与windows10环境搭建深度学习的框架，还有在Jupyter下运用TensorFlow做的一些例子，<br>以来熟悉TensorFLow的最基础操作。  </p><a id="more"></a><h1 id="TensorFlow的组成单元与基本思想"><a href="#TensorFlow的组成单元与基本思想" class="headerlink" title="TensorFlow的组成单元与基本思想"></a>TensorFlow的组成单元与基本思想</h1><p>TensorFlow是一个基于数据流编程（dataflow programming）的符号数学系统，被广泛应用于各类机器学习（machine learning）算法的编程实现。<br>TensorFlow大致框架为下图：<br><img src="/2020/02/05/TensorFlow/p1.PNG" alt="框架">  </p><ul><li>TensorFlow 的核心在于构建运算图（Graph），需要做的是往运算图中加入元素，定义出一套“运算规则”。</li><li>TensorFlow构建的图是静态图，搭建好了之后没法进行更改，但可以使用一些方法使得它在静态图内部又一些动态性（如用tf.cond使模型可支持条件语句）。同时，通过利用“占位符（placeholder）”让TenserFlow具有较强的灵活性。</li><li>使用 feed 和 fetch 可以为任意的操作(arbitrary operation) 赋值或者从其中获取数据</li><li>节点被称之为 op (operation 的缩写). 一个 op 获得 0 个或多个 Tensor, 执行计算, 产生 0 个或多个 Tensor. 每个 Tensor 是一个类型化的多维数组</li><li>Sessio可以“启动”由Graph定义的运算规则，而在启动的过程中，Session又可以做额外三件事：<ul><li>赋予“运算规则”中一些“占位符”一些具体的值；</li><li>根据可能存在的占位符的取值和相应的运算规则，提取出想要的中间结果；</li><li>如果启动的运算规则包括“更新参数（train_step）”这个运算规则的话，就更新相应的可训练变量。</li></ul></li><li>TensorFlow的基本元素有三种：常量(Constant)、可训练变量(Variable)和不可训练的变量(Variable（trainable=False）),而这三种基本元素可以统称为张量（Tensor）。</li><li>TensorFlow模型的训练通常分三步走：<ul><li>把算法的损失函数在运算图中表示出来。</li><li>根据超参数设置来定义一个优化器。 </li><li>利用优化器和运算图中的损失函数来得到一个更新步骤(train_step),然后执行sess.run(train_step)之类的语句来完成模型的迭代。  </li></ul></li></ul><h1 id="Window10下搭建环境"><a href="#Window10下搭建环境" class="headerlink" title="Window10下搭建环境"></a>Window10下搭建环境</h1><p>因为服务器到期，因此不得不要在自己的机器上搭建环境。<br>我机器上未安装python等，因此我采用了anaconda来快速搭建。</p><p>Anaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。<br>下载可以去官网进行下载，我因为在官网下载太慢于是用了<a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">清华的镜像</a>下载，我下载的版本是<br><img src="/2020/02/05/TensorFlow/p2.PNG" alt="版本信息"><br>下载好了，之后便开始安装，在下图中两个选项均选择上<br><img src="/2020/02/05/TensorFlow/p3.PNG" alt=""></p><p>之后便可以看到安装完成。<br><img src="/2020/02/05/TensorFlow/p4.jpg" alt="">   </p><p>以管理员身份打开Anaconda Prompt，键入<code>pip install tensorflow</code><br>便可下载tensorflow库，在这种可能会遇到如下问题：  </p><ol><li>下载过慢<br>便可输入 <code>pip -i 镜像地址 -u tensorflow</code> </li><li>下载的版本不是我需要的版本，则输入以下代码：<br><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ --upgrade tensorflow==1.0.1</code></li><li>对镜像地址不信任<br>可在镜像地址前加  <code>--trusted-host</code></li></ol><p>判断是否可以使用安装好<br><img src="/2020/02/05/TensorFlow/p5.jpg" alt=""> </p><p>使用Jupyter NoteBook时也会遇到一些问题，如需改其工作路径，需要在用户目录下的.jupyter中找到jupyter_notebook_config.py文件，若没有则百度吧，一行命令就可以了。<br>算了，只需在命令行敲入<code>jupyter notebook --generate-config</code>便可。<br>随后，只需修改文件中的文件路径，改为需要使用的路径：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.notebook_dir = <span class="string">"文件路径"</span></span><br></pre></td></tr></table></figure></p><p>便可。<br>以上大致基础配置已经完成。  </p><h1 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h1><ol><li>简单的创建图和启动图<br><img src="/2020/02/05/TensorFlow/p6.png" alt="">  </li><li>变量的操作<br><img src="/2020/02/05/TensorFlow/p7.jpg" alt=""></li><li>fetch和feed<br><img src="/2020/02/05/TensorFlow/p8.jpg" alt=""> </li><li>tensorflow的一个简单示例<br><img src="/2020/02/05/TensorFlow/p9.jpg" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要简述TensorFLow1的组成单元于基本思想，同时与windows10环境搭建深度学习的框架，还有在Jupyter下运用TensorFlow做的一些例子，&lt;br&gt;以来熟悉TensorFLow的最基础操作。  &lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://wangyibo.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://wangyibo.top/categories/%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow" scheme="http://wangyibo.top/categories/%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://wangyibo.top/tags/TensorFlow/"/>
    
      <category term="机器学习" scheme="http://wangyibo.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://wangyibo.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>神经网络入门</title>
    <link href="http://wangyibo.top/2020/02/03/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8/"/>
    <id>http://wangyibo.top/2020/02/03/神经网络入门/</id>
    <published>2020-02-03T08:39:47.000Z</published>
    <updated>2020-02-03T08:39:36.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神经网络的结构"><a href="#神经网络的结构" class="headerlink" title="神经网络的结构"></a>神经网络的结构</h1><p>Logistic回归可以视为神经网络的基本单元，但要做一个扩展，把范围不必拘束到0-1。表达式可以表示为</p><script type="math/tex; mode=display">f(\vec x) = \phi (w_{0}+\vec w^T \vec x)</script><a id="more"></a><p>$\phi$是“激活函数”。而由于模型叫做神经网络，所以通常称这个基本运算单元为“神经元”。<br>在神经网络中，将这些神经元进行“堆叠”，就获得更大、更复杂的模型。将很多神经元组成一个“层”结构，然后将多个层依次排开，并使用矩阵运算来作为层与层之间的联系。<br>由于这些神经元被视为一个整体，因此公式也因该进行整合:  </p><script type="math/tex; mode=display">f(\vec x) \triangleq (f_{1}(\vec x),f_{2}(\vec x),....,f_{n}(\vec x))^T=\phi(W_{0} + W\vec x)</script><script type="math/tex; mode=display">W_{0}=(w_0^{(1)},w_0^{(2)},...w_0^{(3)})</script><script type="math/tex; mode=display">W  = \begin{bmatrix} W_1^{(T)} \\ W_2^{(T)} \\ \vdots \\ W_n^{(T)} \end{bmatrix}</script><p>将许多层视为一个整体并作为神经网络的模型。而一般在神经网络中会有很多层，于是神经网络就会比较“深”，因此叫做“深度”学习。<br><strong>在神经网络中，输入、输出以及中间的所有运算都由层结构完成。</strong>  </p><p>由此，对于神经网络有三个超参数：  </p><ul><li>层结构个数</li><li>每个层结构中神经元个数</li><li>每个层结构对应的激活函数个数<br>参数至少有两个：</li><li>每一层的偏置量（$W_0^{(i)}$）</li><li>层与层之间的权值矩阵（$W^{(i)}$）  </li></ul><h1 id="向前传导算法"><a href="#向前传导算法" class="headerlink" title="向前传导算法"></a>向前传导算法</h1><p>——————神经网络进行输出的基础<br>可大致分为三步：</p><ul><li>输入层将原始输入进行数据预处理并将结果输出。  </li><li>每个隐藏层都会把上一层的输出做一个线性映射后当成自己的输入。   即$W_0^{(i)} + W^{(i)}o^{i-1}$  </li><li>对于输出层，则是通过变换函数来将模型的原始输出变换为最终输出。 </li><li>根据事先定义好的损失函数L，利用模型输出和相应的真实标签来算出模型的损失。  </li></ul><p>此算法的核心在于：</p><ul><li>层与层之间的线性映射。 $W_0^{(i)} + W^{(i)}o^{i-1}$ 其中$o^{i-1}$为上一层的输出</li><li>层结构内部激活函数的使用。  $\phi^{(i)}$  </li></ul><p>其中三个参数的作用：  </p><ul><li>权值矩阵$W^{(i)}$能将数据线性映射到高维空间中。  </li><li>偏置量$W_0^{(i)}$能打破模型的对称性。  </li><li>激活函数$\phi^{(i)}$能提供非线性性。  </li></ul><h2 id="一些激活函数"><a href="#一些激活函数" class="headerlink" title="一些激活函数"></a>一些激活函数</h2><ul><li>逻辑函数(Sigmoid)</li><li>正切函数(Tanh)  </li><li>线性整流函数(ReLU)</li><li>Leaky ReLU函数  </li><li>ELU函数</li><li>SELU函数</li><li>softplus函数</li><li>Swish函数  </li></ul><p>针对函数的选取，引用cs231n上的选择方法：<br>先选取ReLU,为此需要仔细调整训练速率防止太多神经元的死亡（因为ReLU在小于0的情况下输出恒为0，所以很可能就卡在恒<br>为0的情况，于它是就‘死亡’了）如果觉得这两个问题很糟心，可以试试Leaky ReLU。不过需要注意的是，永远不要用Sigmoid，如果真的想用就用Tanh来代替它，不过需要<br>做好Tanh的最终表现会比ReLU差的准备。  </p><p>输入层的“激活函数”其实是数据预处理函数，如标准化；输出层的是变换函数，如Softmax函数（将输出层得到的输入，视为正比于概率向量的对数，并<br>通过简单的变换得到概率输出）。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>是模型在某个样本上的表现。模型表现的越差意味着损失越大。<br>需要对损失函数求梯度（用梯度下降算法）来更新模型的参数。<br>损失函数的选取很大程度上取决于输出层的变换函数。  </p><ul><li>（欧式）距离损失函数</li><li>交叉熵</li><li>log-likelihood损失函数  </li></ul><h1 id="反向传播算法（BackPropagation）"><a href="#反向传播算法（BackPropagation）" class="headerlink" title="反向传播算法（BackPropagation）"></a>反向传播算法（BackPropagation）</h1><p>神经网络是很依赖于梯度下降算法的，而梯度下降算法要求算出各个参数的梯度。而由于神经网络相对复杂，所以直接对每个参数求梯度会带来无法忍受的时间<br>开销。反向传播算法是一个可以能够高效计算各个参数梯度的方法，利用链式法则，一层一层的地将网络中的梯度算出来。<br>简单理解就是，根据损失函数求出输出层对应的梯度，由于样本和损失函数都已经给定，所以第一个已知量是损失函数对模型输出的梯度，以后就是从这个已知量，<br>一层一层的向前推导，得到各个参数的梯度。  </p><h1 id="参数的更新"><a href="#参数的更新" class="headerlink" title="参数的更新"></a>参数的更新</h1><p>由反向传播算法，已经得到了梯度，于是要利用梯度运用梯度下降算法进行参数的更新。 </p><h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><ul><li>朴素梯度下降算法(Vanilla Update)<br>虽然叫做“朴素”，但现实中可以用来做基准线，即定一个下界；或在时间充裕的情况下，有可能优于下述算法。<br>更新方向是负梯度方向<br>学习速率（一次改进多少）是常量</li></ul><p>对朴素下降算法有两种优化：</p><ol><li>不是简单的把负梯度作为更新方向，而是利用更多的（历史）属性来定出更新方向。  </li><li>不单纯地把学习速率设为常量，而设法让器能够“适应算法”并作出调整。  </li></ol><ul><li>Momentum Update(动量法)<br>模仿物理上的“惯性”，不会出现Vanilla Update中，上一秒还在猛地向前冲，下一秒突然向后撤的显现，即有一个缓冲。  </li><li><p>Nesterov Momentum Update(NAG)<br>在凸优化问题下的收敛性会比传统的Momentum好。具有“前瞻性”。  </p></li><li><p>AdaGrad<br>上述两种都是争对1的优化，此方法和下一个方法利用历史信息来调整学习速率。<br>如果某个位置积累下的梯度足够多的话，就认为这个位置训练的已经差不多了，所以就让对应梯度的影响变小。<br>缺点：只能小，不能大  </p></li><li>RMSProp<br>对上述进行了改进，可以小，可以大。  </li><li>Adam<br>是上述方法的集大成者。  </li></ul><p>一般来说，如果不知道使用哪种优化算法，使用Adam常常是个不错的选择。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;神经网络的结构&quot;&gt;&lt;a href=&quot;#神经网络的结构&quot; class=&quot;headerlink&quot; title=&quot;神经网络的结构&quot;&gt;&lt;/a&gt;神经网络的结构&lt;/h1&gt;&lt;p&gt;Logistic回归可以视为神经网络的基本单元，但要做一个扩展，把范围不必拘束到0-1。表达式可以表示为&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(\vec x) = \phi (w_{0}+\vec w^T \vec x)&lt;/script&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://wangyibo.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="神经网络" scheme="http://wangyibo.top/categories/%E7%AC%94%E8%AE%B0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="机器学习" scheme="http://wangyibo.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://wangyibo.top/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Pr CC 2018 基础教程</title>
    <link href="http://wangyibo.top/2020/01/22/Pr-CC-2018-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <id>http://wangyibo.top/2020/01/22/Pr-CC-2018-基础教程/</id>
    <published>2020-01-22T14:02:46.000Z</published>
    <updated>2020-01-22T14:14:59.294Z</updated>
    
    <content type="html"><![CDATA[<p>本文是为了快速上手Pr而写的一篇基础性指导文章，适合一个新手小白，快速的了解Pr剪辑的一些步骤和简单的进行一些操作，关于深层次的说明，更深入的视频剪辑技巧，本文不做过多的叙述。我是用的是Pr Pro CC 2018，其他版本一些操作大同小异，可以作为参考。<br><a id="more"></a></p><h1 id="制作一个视频"><a href="#制作一个视频" class="headerlink" title="制作一个视频"></a>制作一个视频</h1><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>渲染程序：如果是NVIDIA显卡选择CUDA加速。<br>其它均选默认。 </p><h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><p>有许多窗口。 万一不小心关掉了面板，可以选择窗口工作区，重置为保存布局。  </p><h2 id="新建序列"><a href="#新建序列" class="headerlink" title="新建序列"></a>新建序列</h2><p>序列相当于一个容器，对要剪辑的素材进行存放。<br>文件-&gt;新建序列 ctrl +n<br>设置<br>时基：一般25帧每秒够用<br>像素长宽比：方形像素<br>采样率：44100Hz  </p><p>导入文件 ctlr + i 也可以直接拖入  </p><p>导出文件 ctlr + m<br>格式： 若导出MP4格式 选择h.264<br>匹配源：高比特率  视频清晰度和比特率有关。<br>目标比特率和最大比特率默认就好了。  </p><h1 id="剪辑技巧及剪辑工具"><a href="#剪辑技巧及剪辑工具" class="headerlink" title="剪辑技巧及剪辑工具"></a>剪辑技巧及剪辑工具</h1><p>~键 放大某个窗口。<br>文件 项目设置 常规中可以修改项目。<br>视频预览窗口 出入点设置。使用i 设置入点，使用o设置出点<br>视频音频都要，就按住画面推入到时间轴中<br>剃刀工具 C 选择工具 V<br>一个视频片段变长，使用波纹编辑工具B，可以不用麻烦移动后面的视频片段。<br>滚动 编辑工具 N  会影响其他的视频片段<br>比率拉伸工具 R  慢放的好工具  </p><h1 id="速度和关键帧"><a href="#速度和关键帧" class="headerlink" title="速度和关键帧"></a>速度和关键帧</h1><p>慢放：右键片段 速度持续时间 若100帧改为25帧，即可以慢放4倍<br>高帧率后期慢放才会流畅<br>右键视频文件，修改 解释素材 也可实现上述效果  </p><p>快放：右键 速度持续时间 把帧升高<br>在预览中快放  空格播放  按l是快放   按j是倒放 不影响视频文件  </p><p>效果控件shift +5 可以弹出此面板  时间重映射  比较好用<br>选择要改变速度开始的一帧，添加关键帧，在速度结束改变的一帧，添加关键帧<br>可以在时间轴中把视频拉大，即竖直拉<br>然后右键 显示剪辑关键帧，时间重映射，速度<br>可以使用钢笔工具P 可以快速打关键帧<br>将关键帧中间往下压， 慢放  </p><h1 id="PR效果"><a href="#PR效果" class="headerlink" title="PR效果"></a>PR效果</h1><p>效果面板，里很多效果控件，可以多尝试一下。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是为了快速上手Pr而写的一篇基础性指导文章，适合一个新手小白，快速的了解Pr剪辑的一些步骤和简单的进行一些操作，关于深层次的说明，更深入的视频剪辑技巧，本文不做过多的叙述。我是用的是Pr Pro CC 2018，其他版本一些操作大同小异，可以作为参考。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://wangyibo.top/categories/%E6%95%99%E7%A8%8B/"/>
    
      <category term="视频剪辑" scheme="http://wangyibo.top/categories/%E6%95%99%E7%A8%8B/%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91/"/>
    
    
      <category term="视频剪辑" scheme="http://wangyibo.top/tags/%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91/"/>
    
      <category term="Pr" scheme="http://wangyibo.top/tags/Pr/"/>
    
  </entry>
  
  <entry>
    <title>简述Java虚拟机</title>
    <link href="http://wangyibo.top/2020/01/21/%E7%AE%80%E8%BF%B0Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://wangyibo.top/2020/01/21/简述Java虚拟机/</id>
    <published>2020-01-21T12:17:00.000Z</published>
    <updated>2020-01-22T16:29:01.499Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JDK</strong> 全称Java SE Development kit由Java程序设计语言、Java虚拟机、JAVA API类库三部分组成，使用于支持Java程序开发的最小环境。<br><strong>JRE</strong> 全称Java runtime environment，包括：Java虚拟机、Java API子集。<br><a id="more"></a></p><h1 id="Java运行时数据区域"><a href="#Java运行时数据区域" class="headerlink" title="Java运行时数据区域"></a>Java运行时数据区域</h1><p>Java虚拟机在执行Java程序的时候会将内存划分为若干个数据区域。每个区域有各自的用途，创建和销毁时间。</p><p>为了方便学习与记忆先进行一个简单的分类：<br><strong>线程共享</strong>：方法区、堆<br><strong>线程隔离</strong>：虚拟机栈、本地方法栈、程序计数器  </p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>是一块较小的内存空间，时当前线程所执行的字节码的行号指示器。Java虚拟的多线程是由线程轮流切换并分配处理器的时间来实现的。<br>当执行Java方法时，程序计数器记录的是正在执行的字节码指令地址；当执行native方法时，计数器值为空。此区域是没有任何情况的OutOfMemoryError的区域。  </p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表（存放编译期的基本数据类型，对象引用，returnAddress类型）、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。<br>此区域有两种异常：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常； 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。   </p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈十分相似，区别在于一个为了Java方法服务，一个为Native方法服务。<br>同样也会抛出StackOverflowError和OutOfMemoryError异常。  </p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>是Java虚拟机所管理的内存中最大的一块，在虚拟机启动时创建。<br>此区域的唯一目的时存放对象实例。<br>Java堆是垃圾收集器管理的主要区域，因此又被称为“GC堆”。<br>从内存回收的角度看，Java堆还可分为：新生代和老年代。从内存分配的角度看，线程共享的Java堆中可能划分多个线程私有的分配缓存区。<br>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时可以是固定大小，也可以是可扩展的。<br>如果堆中没有内存完成实例分配，并且堆也无法在扩展，将会抛出OutOfMemoryError异常。  </p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。<br><strong>运行时常量池</strong> 方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一样信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。<br>同样有OutOfMemoryError异常。  </p><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。作用是提高性能，避免在Java堆和Native堆中来回复制数据。<br>也有OutOfMemoryError异常。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;JDK&lt;/strong&gt; 全称Java SE Development kit由Java程序设计语言、Java虚拟机、JAVA API类库三部分组成，使用于支持Java程序开发的最小环境。&lt;br&gt;&lt;strong&gt;JRE&lt;/strong&gt; 全称Java runtime environment，包括：Java虚拟机、Java API子集。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://wangyibo.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java" scheme="http://wangyibo.top/categories/%E7%AC%94%E8%AE%B0/Java/"/>
    
    
      <category term="Java" scheme="http://wangyibo.top/tags/Java/"/>
    
      <category term="JVM" scheme="http://wangyibo.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>几种经典传统机器学习算法</title>
    <link href="http://wangyibo.top/2020/01/20/%E5%87%A0%E7%A7%8D%E7%BB%8F%E5%85%B8%E4%BC%A0%E7%BB%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://wangyibo.top/2020/01/20/几种经典传统机器学习算法/</id>
    <published>2020-01-20T06:57:58.000Z</published>
    <updated>2020-01-23T01:32:26.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在前文初入机器学习中，已经简要介绍了一些基本术语。本文简单介绍机器学习最为经典的五种算法：朴素贝叶斯，决策树，感知机，支持向量机和Logistic回归。简要阐述一下他们的思想。  </p><a id="more"></a><h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><p>分为 <strong>朴素</strong> 和 <strong>贝叶斯</strong> 两个部分。分别对应条件独立性假设，和贝叶斯思维。</p><h2 id="条件独立性假设"><a href="#条件独立性假设" class="headerlink" title="条件独立性假设"></a>条件独立性假设</h2><p>通常会假设训练集为$D=\{(x_{1},y_{1}),…,(x_{N},y_{N})\}$，而且除了特殊的问题（如时序问题）以外，通常会假设$D$中的各个样本之间总是独立的，通俗来说就是<strong>毫无关系</strong>的。即数学关系式如下：  </p><script type="math/tex; mode=display">p(D_{i};\theta)=\prod_{i=1}^N p(D_{i};\theta)=\prod_{i=1}^N p(x_{i},y_{i};\theta)</script><p>其中$D_{i}=(x_{i},y_{i}) i = 1,2…N$<br>而条件独立性假设则要更强一些，即对于每个类别来说，特征之间是相互独立的。即$p(\vec x|y;\theta)=\prod_{i=1}^N p(x^(i)|y;\theta)$  是一个事实上很难满足的假设，因此有<strong>朴素</strong>的概念。</p><h2 id="贝叶斯思维"><a href="#贝叶斯思维" class="headerlink" title="贝叶斯思维"></a>贝叶斯思维</h2><p>指的是这样一种思想：我们需要在一个问题的解决方案中加入<strong>先验知识</strong>，然后根据先验知识进行<strong>推理</strong>并总结出<strong>后验知识</strong><br>但贝叶斯思维不是十全十美的。有时“简单的”决策可能会更合理。如先验知识知识不足时。<br>贝叶斯思维认为当先验知识足够完备时，一件事情发展趋势就是确定的：通过恰当的推理后，就能够得到完备的后验知识。当先验知识不足时，一件事的发展就充满了随机性，再怎么推理也只能得到带随机性的后验知识。  </p><h2 id="模型算法"><a href="#模型算法" class="headerlink" title="模型算法"></a>模型算法</h2><p>概率模型和普通模型相比，输出的会是一个概率值而不是一个用于分类或回归的、不具备概率含义的数值。<br>输入的特征向量为$\vec x$ ,概率模型为$P$,相应的普通模型为$G$,模型的参数为$\Theta$，过程就不进行推导，直接给出朴素贝叶斯算法：  </p><p>输入训练集<br>过程：  </p><ol><li>估计先验概率  $p(y_{k})$</li><li>估计条件概率   $p(x\ast^(i)|y_{k}$</li></ol><p>输出：朴素贝叶斯模型，能够估计数据$x*$的类别：  </p><script type="math/tex; mode=display">y\ast = G(\vec x\ast) = arg max_{k} p(y_{k})\prod_{i=1}^N p(x\ast^i | y_{k};\Theta)^(x^ \ast(i))</script><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>对于机器，决策方式的本质就是：根据输入的数据在经过一系列的计算后，根据计算结果来按照预先给定的指示和规则进行决策。<br>我们的目标是寻找一种算法，使机器可以自动生成决策路径。可阐述为：挑选出$\vec x$中的某个具有代表性特征$x^(i)$作为“问题”，根据他的取值来分情况讨论。     </p><p>算法有两个关键点：  </p><ol><li>怎样算“最具代表性的特征”</li><li>怎样算“足以做出决策” </li></ol><p>简单来说，其实就是不断挑选出特征并对特征向量空间进行划分，当空间被划分到信息量很少的时候，就会给这个子空间打上标签，当一个新的特征向量进入模型时，只需看它属于哪个子空间，然后输出相应的标签即可。  </p><p>在决策树中，过拟合的问题尤为严重。因此需要一些措施来防止过拟合—-剪枝。  </p><h1 id="感知机和支持向量机SVM"><a href="#感知机和支持向量机SVM" class="headerlink" title="感知机和支持向量机SVM"></a>感知机和支持向量机SVM</h1><p>感知机和SVM的核心思想都是：在特征向量空间中找到一个超平面，使得他们能把两个类别的样本划分开，即找到一个合适的超平面。举个简单的例子，一张纸好似一个向量空间，而超平面就是在这张纸上画一条直线，将纸分为两部分。<br>超平面公式可写成：$f_{\Pi}(\vec x) = sign(w_{0}+\vec w^T \vec x)$<br>这么一看，感知机与支持向量机仿佛和决策树有些相像，但还是有区别的： </p><ul><li>决策树一般会将特征向量空间划分为很多个子空间，感知机和SVM则只会划分两个子空间。  </li><li>决策树在划分空间时，一般用于划分的超平面都是垂直于某个维度的（不垂直也是存在的），而感知机和SVM的分离超平面则可以是任意一个超平面。  </li></ul><p>感知机和支持向量机也有不同，感知机只能保证对线性可数据集进行正确分类，没有考虑过多的泛化能力；而SVM通过考虑优化几何间隔（可以简单理解为不同数据距离分离超平面的距离）来增强模型的泛化能力。<br>感知机模型表达式： $G(\vec x) = sign(w_{0}+\vec w^T \vec x)$</p><h1 id="logistic回归"><a href="#logistic回归" class="headerlink" title="logistic回归"></a>logistic回归</h1><p>可以简单的理解，logistic回归可以看作感知机模型的“概率版”，即它将感知机模型中的两个类别，假设为1，-1，变成了一个函数在（0-1）上，从而使模型具有概率的意义。<br>模型表达式： $G(\vec x) = \sigma(w_{0}+\vec w^T \vec x)$</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在前文初入机器学习中，已经简要介绍了一些基本术语。本文简单介绍机器学习最为经典的五种算法：朴素贝叶斯，决策树，感知机，支持向量机和Logistic回归。简要阐述一下他们的思想。  &lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://wangyibo.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://wangyibo.top/categories/%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://wangyibo.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="http://wangyibo.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="python" scheme="http://wangyibo.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>初入机器学习</title>
    <link href="http://wangyibo.top/2020/01/16/%E5%88%9D%E5%85%A5%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://wangyibo.top/2020/01/16/初入机器学习/</id>
    <published>2020-01-16T11:24:57.000Z</published>
    <updated>2020-01-21T06:45:30.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着人工智能的日渐火爆，机器学习的概念也日渐为人所熟知，本文用针对机器学习的一些概念及常用术语进行总结，便于日后深入的学习。</p><a id="more"></a><p>首先了解一下机器学习、深度学习、神经网络、人工智能、之间的关系  </p><ul><li>神经网络是深度学习的“根基”  </li><li>深度学习是机器学习的一个分支点  </li><li>机器学习是人工智能领域的一种技术  </li></ul><hr><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>机器学习听上去很复杂，但其实就是两部分，“机器”，“学习”；<br>“机器”： 是拥有“没有生命”“能够进行与算法”“服从人类指令”等基本属性物件<br>“学习”： 和人类的学习有相似之处，但它与外界交互的媒介只有——数据<br>因此，机器学习的核心有两个：<strong>算法</strong>，<strong>数据</strong>。</p><h2 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h2><p>以下术语看起来高大上，但可以非常直观的理解，虽然背后的数学背景五花八门，我们先撇开他们，也不会对实际应用造成影响。（当然如果要做到顶尖的话，相应的背景知识是要补上的）  </p><ul><li><p><strong>模型（Model）</strong>某个机器算法导出的、能完成训练与预测等任务的物件，常用G来指代它。我们需要做的就是使用数据来训练G，并让G能够解决一系列问题。 G可分为<strong>分类器</strong>和<strong>回归器</strong>。 </p><ul><li><p><strong>参数（Parameter）</strong>决定模型行为的东西，训练的目的就是把参数训练到一个模型能表现的最好值。一般用θ来指代；$G(x|θ)$表示<strong>G在参数θ下的行为</strong></p><script type="math/tex; mode=display">G(x)=G(x|θ)</script></li><li><p><strong>超参数（Hyper Parameter）</strong>决定模型结构或训练行为的东西。一般不能被训练只能被选择。 不过需要单独指名的场景很少，一般将超参数和参数视为一个整体。可用Θ表示</p><script type="math/tex; mode=display">G(x)=G(x|Θ)</script></li></ul></li><li><p><strong>空间（Space）</strong>常作为后缀出现，若没有特别指出，表示的就是前面的词语“可能存在的值”；如模型空间则表示所有模型，参数空间表示所有参数</p></li><li><strong>数据集（Date Set）</strong>数据的集合</li><li><strong>样本（Sample）</strong>数据集中每一条单独的数据。若没特殊说明则有<em>N</em>个样本，用符号：$D=\{(x_{1},y_{1}),…,(x_{N},y_{N})\}$表示，其中的每一个就是一个样本，他又包含以下两部分。  <ul><li><strong>特征向量（Feature Vector）</strong>是样本中的$x_{i}$，常常是模型的输入来源。既可以把特征向量直接输入模型$(x_{i}\longrightarrow G)$，也可以先对特征向量中的各个“特征”进行“预处理（Preprocess）”在作为模型的输入。一般而言，会假设特征向量是<br>n维列向量，即一个特征向量中有n个特征（Feature）<br>对于特征而言，大体上可分为两种：离散型特征和随机型特征   </li><li><strong>标签（Label）</strong>是样本中的$y_{i}$，是模型的目标。最终目的就是能让“特征向量空间”中的每个特征向量x在输入模型G后，都能输出相对应的、正确的标签y<br>对于标签而言，也分为离散的和连续的。  </li></ul></li></ul><p>数据集可以划分三类： </p><ul><li><strong>训练集（Train Set）</strong>模型G实际受到的数据。通常，为了使模型能在未知数据上表现的更好（“泛化能力”更好），取数据集中的 <strong>一部分</strong> 作为训练集，通常用$D=\{(x_{1},y_{1}),…,(x_{N},y_{N})\}$表示  </li><li><strong>交叉验证集（Cross Validation Set）</strong>是G能看不能用的数据。具体说，G使用训练集来训练，并会时不时的观察一下它在交叉验证集上的表现来决定是否继续训练，以及是否需要调节它自身的设置  </li><li><strong>测试集（Test Set）</strong>用来评估G的性能的数据，是G“看不到”的数据。总之，测试集不会参与到训练当中，在实际搭建机器学习模型时一定要注意把它和交叉验证集分开  </li></ul><p>上文提到过，最终目的是<strong>能让特征向量空间中的每个特征向量在输入模型后，都能输出相对应的，正确的标签。</strong>因此模型空间中存在一个“正确的”模型$\hat{G}$，即$\hat{G}(x)=y(\forall x \in \chi)$<br>我们的目的则是让$G$接近$\hat{G}$，作为判断定义一个<strong>损失函数</strong> <em>L</em><br>但损失函数是<strong>局部</strong>的，因此需要定义一个<strong>全局</strong>的<strong>代价函数</strong> <em>C</em>  </p><script type="math/tex; mode=display">C(G,\hat{G})=C(G,D)=1/N\sum_{i=1}^{n}(G(x_{i}),\hat{G}(x_{i}))</script><p>可以用梯度下降算等算法降低代价函数  </p><ul><li><strong>过拟合（Over Fitting）</strong>如果$G$在训练数据$D$上表现优异，但在样本空间如$\mathcal{D}的其余采样（如交叉实验集或测试集）上表现糟糕，则说$G$泛化能力差，或此时产生了“过拟合”  </li><li><strong>欠拟合（Under Fitting）</strong>即使在训练集$D$上，模型$G$的表现也很差  </li></ul><p>所以一个很自然的想法就诞生了：找到过拟合和欠拟合之间的一个平衡点，<strong>结构风险最小化（SRM）</strong>就是上述的思想，与之相对的是<strong>经验风险最小化（REM)</strong><br>因此我们需要对$G$加入一定的<strong>限制</strong>，一般表现在假设空间（使风险上界最小的函数子集）的选取上。实际操作上，普遍上是对$G$复杂度做出一定的惩罚，从而使$G$趋于精简。</p><script type="math/tex; mode=display">\hat{C}(G,\hat{G})=C(G,\hat{G})+\lambda G_{complexity}</script><p>这种惩罚模型的复杂度称为<strong>正则化</strong>，$\lambda$称为<strong>正则化系数</strong>，反映模型复杂度的<strong>惩罚力度</strong>  </p><p>相比于选取合适的假设空间来规避过拟合，进行交叉验证可以知道过拟合程度，可以<br>帮助选择合适的模型。以下有三种常见的交叉验证：  </p><ul><li><strong>K-fold Cross Validation K折交叉验证</strong>  方法如下<ul><li>将$D$分成$K$份：$D=\{ D_{1},D_{2},…,D_{K} \}$,一共做$K$次实验  </li><li>在第i次实验中，使用$D-D_{i}$作为训练集，$D_{i}$作为交叉验证集来训练，评测$G$  </li><li>最终选择平均交叉验证误差最小的模型  </li></ul></li><li><strong>留一交叉验证</strong>K折交叉验证的特殊情况，此时$K=N$,即每次只从数据集中“留出一个样本”作为评测标准  </li><li><strong>简易交叉验证</strong>将数据随机或不随机分组，最后达到训练集约占原数据的90%的程度，选择模型时同样使用评测误差作为标准  </li></ul><h2 id="工具选取"><a href="#工具选取" class="headerlink" title="工具选取"></a>工具选取</h2><blockquote><p>人生苦短，我用Python  </p></blockquote><p>从数据的获取（网络爬虫），到数据的清洗、预处理、到模型的搭建（传统机器学习算法库scikit-learn,以及以TensorFlow为代表的各种深度学习框架），到结果可视化（第三方库matplotlib),甚至到服务器交互（第三方工具jupyter notebook),Python都有非常完备的解决方案。</p><p>关于机器学习最具代表性的两个库————传统机器学习算法库scikit-learn神经网络框架TensorFlow。  </p><h2 id="关于安装第三方库"><a href="#关于安装第三方库" class="headerlink" title="关于安装第三方库"></a>关于安装第三方库</h2><p>因为要安装上面所说的库，需要提前安装一些依赖，但较为麻烦，因此使用Anaconda，它是一个Python优质的集成环境，可以减少这些麻烦。可以访问<a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener">官网</a>进行下载，在此处就不多赘述。  </p><p>我在ubuntu环境下已安装，我并未选用上述方法，因此安装了以下库  </p><pre><code>pip install scipypip install numpypip install -U scikit-learn   pip install -U tensorflow </code></pre><p>就安装完需要用的库了，使用  </p><pre><code>pip list</code></pre><p>查看是否安装成功<br><img src="/2020/01/16/初入机器学习/1.jpg" alt="">  </p><p><strong>需要注意</strong> 在linux环境下使用pip默认会安装到python2的dist-packages下，而如果要使用python3，则需要使用pip3来安装相应的包。<br>检查是否安装好了tensorflow，可以在python中输入import tensorflow看是否报错来进行验证  </p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="数据读入"><a href="#数据读入" class="headerlink" title="数据读入"></a>数据读入</h3><p>数据可分为两种：结构化数据和非结构化数据<br>计算机的眼中，数据并不是一个表格，而通常是由分隔符分开的文本文档<br>现在需要做的就是：读入数据，并将数据集划分为训练集、交叉验证集与测试集<br>同时针对非数字类型则需要对其进行预处理，转换为数字类型，完成数据的数值化后，为了跟好的结果，应该进一步处理，即预处理。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文大致阐述了机器学习，深度学习，神经网络之间的关系，重点对机器学习的相关术语进行了总结，对环境也进行了大致的配置。同时进行了前期准备，对数据集如何用python进行具体操作进行了介绍。<br>下一篇应会对传统的机器学习算法进行简单的介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;随着人工智能的日渐火爆，机器学习的概念也日渐为人所熟知，本文用针对机器学习的一些概念及常用术语进行总结，便于日后深入的学习。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://wangyibo.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="机器学习" scheme="http://wangyibo.top/categories/%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://wangyibo.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://wangyibo.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="python" scheme="http://wangyibo.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Github+hexo+Next的博客搭建</title>
    <link href="http://wangyibo.top/2020/01/15/Github-hexo-Next%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://wangyibo.top/2020/01/15/Github-hexo-Next的博客搭建/</id>
    <published>2020-01-15T10:17:21.000Z</published>
    <updated>2020-01-16T15:19:31.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>早在两年前就开始了博客编写，但因为个人原因，只进行了短时间的记录，长时间没有对博客进行更新，同时当时未对掌握的技术进行总结，造成如今的从零开始进行学习，故改博客名为”从零开始”对自己进行警醒，但关于hexo安装，Github注册等早在以前就已经完成，故此处不进行过多赘述，只针对相关操作命令及一些配置文件内容进行总结。<br><a id="more"></a></p><hr><h1 id="零碎的积木"><a href="#零碎的积木" class="headerlink" title="零碎的积木"></a>零碎的积木</h1><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>Hexo是一个快速，简洁高效的博客框架，有众多优秀的主题。Hexo使用Markdown解析文章，在几秒内即可利用靓丽的主题生成静态网页。关于<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo的安装</a>不详细展开</p><h2 id="Github-Page"><a href="#Github-Page" class="headerlink" title="Github Page"></a>Github Page</h2><p>github page是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 Github 上，可以选择使用 Github Pages 默认提供的域名 github.io 或者自定义域名来发布站点。</p><h2 id="NexT主题"><a href="#NexT主题" class="headerlink" title="NexT主题"></a>NexT主题</h2><p>一款Hexo上的主题，GitHub上star最多的主题，一直在维护和更新，支持非常多的外部插件和功能选项。<br>主题的下载在终端窗口下，定位到hexo站点目录下。使用以下命令便可轻松下载<br><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p><h2 id="MarkDown"><a href="#MarkDown" class="headerlink" title="MarkDown"></a>MarkDown</h2><p>Markdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档</p><hr><h1 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h1><h2 id="两个配置文件"><a href="#两个配置文件" class="headerlink" title="两个配置文件"></a>两个配置文件</h2><p>有两个配置文件都叫做_config，一个位于hexo站点底下，称为<strong>站点配置文件</strong>,一个位于主题目录下，称为<strong>主题配置文件</strong>  </p><h3 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h3><p>主题选择 <code>theme: next</code><br>网站标题 <code>title: 从零开始</code><br>网站副标题 <code>subtitle: 叶子( •̀ ω •́ )y</code><br>网站描述 <code>description: hello world</code><br>网站的关键词 <code>keywords: 王一博的博客</code><br>您的名字 <code>author: wangyibo</code><br>网站使用的语言 <code>language: zh-Hans</code>  </p><h3 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h3><p>头像设置:<code>avatar: http://example.com/avatar.png</code><br>菜单设置:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">        home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">        about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line"><span class="attr">        tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">        categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">        archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure></p><p>选择 Scheme<br>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p><p>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白<br>Mist - Muse 的紧凑版本，整洁有序的单栏外观<br>Pisces - 双栏 Scheme，小家碧玉似的清新  </p><h2 id="如何写一篇博客"><a href="#如何写一篇博客" class="headerlink" title="如何写一篇博客"></a>如何写一篇博客</h2><p>基础的配置大致完成后，接下来需要进行博客的编写。<br>Hexo 有三种默认布局：post、page 和 draft。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。而写的文章的布局为<strong>post</strong>。  </p><ol><li><p>在source/_posts文件夹中新建一个以md为后缀名的文档<br>可以直接新建一个文档，也可以在终端输入<code>hexo new [post] &quot;文件名.md&quot;</code>，后一个方法建立的markdown文件会有如下信息,且文件名就是title的内容，使用较为方便，而第一个方法，需要手动打出相应信息。  </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span><span class="bullet">--</span>  </span><br><span class="line"><span class="attr">title:</span> <span class="string">Github+hexo+Next的博客搭建</span>  </span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="bullet">-01</span><span class="bullet">-15</span> <span class="number">18</span><span class="string">:17:21</span>  </span><br><span class="line"><span class="attr">tags:</span> <span class="string">[Git,Hexo,NexT]</span>  </span><br><span class="line"><span class="string">categories：分类</span>  </span><br><span class="line"><span class="attr">updated:</span> <span class="string">更新日期</span>  </span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li><li><p>运用相应的markdown语法进行博文的编写，NexT提供<code>&lt;!--more--&gt;</code>语法，可用作分割，将文章只显示其之前的内容，而进入后则提供全文阅读。     </p></li><li>在使用是可利用<code>hexo s --debug</code>进行本地服务运行，可通过<strong>localhost:4000</strong>进行访问预览。但使用之前需要使用<code>npm install hexo-server --save</code>安装相应的模块。  </li><li>一切完成后便可向github上进行部署。<br>1.首先需要进入<strong>站点配置文件</strong>进行修改配置  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">git@github.com:ahahou/ahahou.github.io.git</span> </span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li></ol><p>2.安装hexo-deployer-git<br><code>npm install hexo-deployer-git --save</code><br>3.使用<code>hexo generate</code>可简写为<code>hexo g</code>生成静态文件。可加参数<code>-d</code>文件生成后立即部署网站,<code>-w</code>监视文件变动。<br>4.使用<code>hexo deploy</code>可简写为<code>hexo d</code>部署网站。  参数<code>-g</code>部署之前预先生成静态文件。<br>大功告成。  </p><hr><h1 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h1><h2 id="关于图片的问题"><a href="#关于图片的问题" class="headerlink" title="关于图片的问题"></a>关于图片的问题</h2><p>hexo博客图片的问题在于，在写markdown时图片的路径与部署之后的图片路径是不一致的。<br>Hexo提供了更组织化的方式管理资源。<br>需要在<strong>站点配置文件</strong>中将<code>post_asset_folder</code>修改为true，而当这个打开后，每次使用<code>hexo new &quot;文件名.md&quot;</code>时便会同时建立一个同名的文件夹，此时便可以将图片等资源放入其中。<br>而在markdown中只需使用<code>![](文件名/图片名)</code>便可成功引用。<br>如果未成功引用，可能时未安装 hexo-asset-image，执行以下命令即可<code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p><h2 id="关于hexo渲染数学公式的问题"><a href="#关于hexo渲染数学公式的问题" class="headerlink" title="关于hexo渲染数学公式的问题"></a>关于hexo渲染数学公式的问题</h2><p>出现问题的原因：<br>Hexo默认使用”hexo-renderer-marked”引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签，比如在markdown语法中，下划线’_‘代表斜体，会被渲染引擎处理为<code>&lt;em&gt;</code>标签<br>解决方法：<br>卸载hexo默认的引擎，使用hexo-renderer-kramed引擎   </p><pre><code>    npm uninstall hexo-renderer-marked --save    npm install hexo-renderer-kramed --save</code></pre><p>接下来修改博客根目录下node_modules\kramed\lib\rules\inline.js</p><pre><code>    //  escape: /^\\([\\`*{}\[\]()#$+\-.!_&gt;])/,    escape: /^\\([`*\[\]()#$+\-.!_&gt;])/    //  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,    em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</code></pre><p>在<strong>主题配置文件</strong>中在开启mathjax开关<br>在文章的Front-matter里添加<code>mathjax: true</code></p><h2 id="关于markdown代码块的问题"><a href="#关于markdown代码块的问题" class="headerlink" title="关于markdown代码块的问题"></a>关于markdown代码块的问题</h2><p>可以使用<strong>缩进</strong>，也可以使用<strong>```</strong>来进行代码块的标注。<br>在使用 <strong>```</strong> 时，结尾的 <strong>```</strong>后不带任何空格，否则会出现错误</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;早在两年前就开始了博客编写，但因为个人原因，只进行了短时间的记录，长时间没有对博客进行更新，同时当时未对掌握的技术进行总结，造成如今的从零开始进行学习，故改博客名为”从零开始”对自己进行警醒，但关于hexo安装，Github注册等早在以前就已经完成，故此处不进行过多赘述，只针对相关操作命令及一些配置文件内容进行总结。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://wangyibo.top/tags/Git/"/>
    
      <category term="Hexo" scheme="http://wangyibo.top/tags/Hexo/"/>
    
      <category term="NexT" scheme="http://wangyibo.top/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="http://wangyibo.top/2018/07/17/Python1/"/>
    <id>http://wangyibo.top/2018/07/17/Python1/</id>
    <published>2018-07-17T13:02:47.000Z</published>
    <updated>2019-01-22T15:19:40.736Z</updated>
    
    <content type="html"><![CDATA[<p>Python:面向对象的解释型程序设计语言。<br>Python:是纯粹的既有软件，源代码和解释器CPython遵循GPL（GNU General Public License)协议。Python语法清晰简洁，特色之一是强制使用空白符座位语句缩进。</p><a id="more"></a><p>交互式命令shell  启动IDLE  打开Python交互式命令shell。  </p><h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><p>列表(list)：有序集合，可以随时添加和删除其中元素。 </p><pre><code>classmates = [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]  </code></pre><p>元组(tuple): 不可修改的列表，经常用于仅遍历的情况。 </p><pre><code>classmates = (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code></pre><p>字典(dict): 存储“键-值”对数据，键不可重复。  </p><pre><code>keys = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]  values = [1,3,7,10]  dict1 = dict(zip(keys,values))students = {&#39;wyb&#39;:1 &#39;zjn&#39;:2}</code></pre><p>集合(set): 集合元素不允许重复  </p><pre><code>set1 = {1,3,4,5}  </code></pre><p>set可看成数学意义上的无序和无重复元素的集合，故可进行数学上的交集，并集运算。  </p><pre><code>s1 = set([1,2,3])  s2 = set([2,3,4])  s1 &amp; s2s1 | s2   </code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>返回值是tuple。 </p><pre><code>def my_function():      pass   </code></pre><p>定义默认参数要牢记一点：默认参数必须指向不变对象！</p><p>可变参数  允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple  </p><pre><code>def my_fun(*number):      pass  </code></pre><p>关键字参数 允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict  </p><pre><code>def my_fun(name, age, **kw):    pass</code></pre><p>命名关键字参数  </p><pre><code>def my_fun(name, age，*， city， home):    pass</code></pre><p>参数组合 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><p>递归函数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python:面向对象的解释型程序设计语言。&lt;br&gt;Python:是纯粹的既有软件，源代码和解释器CPython遵循GPL（GNU General Public License)协议。Python语法清晰简洁，特色之一是强制使用空白符座位语句缩进。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://wangyibo.top/tags/Python/"/>
    
      <category term="笔记" scheme="http://wangyibo.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSS基础</title>
    <link href="http://wangyibo.top/2018/07/03/CSS%E5%9F%BA%E7%A1%80/"/>
    <id>http://wangyibo.top/2018/07/03/CSS基础/</id>
    <published>2018-07-03T05:47:32.000Z</published>
    <updated>2019-01-22T15:08:19.815Z</updated>
    
    <content type="html"><![CDATA[<p>CSS概念    </p><ol><li>CSS（Cascading Style Sheet）层叠样式表，也称为级联样式表，用来设计网页风格   </li><li>在网页制作时采用CSS技术，可以有效地对页面的布局、字体、颜色、背景和其他效果实现更加精确的控制。  </li><li>只要对相应的代码做一些简单的修改，就可以改变同一页面的不同部分，或者不同网页的外观和格式。  </li></ol><a id="more"></a><p>传统HTML的缺点  </p><ul><li>维护困难  </li><li>标记不足  </li><li>网页过“胖”  </li><li>定位困难  </li></ul><p>CSS属于动态HTML技术。  </p><p>CSS特点：  </p><ol><li>页面的字体变得更漂亮、更容易编排。  </li><li>可以轻松控制页面的布局。  </li><li>可以在不同的浏览器上使用。  </li><li>以前一些必须通过图片转换实现的功能，现在只要用CSS就可以轻松实现，从而更快地下载页面。  </li><li>可以实现网站网页的风格统一，只需要修改CSS文件，整个站点的所有页面风格都会随之改变。   </li></ol><p>CSS的优势:   </p><ol><li>表现和内容相分离  </li><li>加强了网页的表现力  </li><li>增强了网站风格的一致性  </li></ol><p>CSS编辑方法  </p><ol><li>写在HTML文件里； </li><li>写在独立的*.CSS文件里。  </li></ol><hr><p><strong>CSS</strong></p><p>CSS语法：<br>CSS是一个由包含一个或多个规则的文本文件。<br> 规则：选择符Selector+  声明部分Declaration<br>选择器:通常是需要改变样式的HTML标记。<br>声明:由一个或多个属性名称与属性值对组成  “:”赋值, “,”多个属性值逗号分隔, “;”分隔  </p><p>CSS选择器类型：  </p><ol><li>标记选择符——对HTML的标记重定义。该样式立即生效。  <blockquote><p>p,h1{font-size:30px;color:blue;font-family:黑体;}</p></blockquote></li><li>类选择符——以点号“.”开头，并可以任意命名，如.div1、.files等，该样式应用后生效，有些标记的样式相同时，可以定义成选择符组。  <blockquote><p>.div1,.file{background:red;color:white;}<br>联合选择器—-标记+类选择器（p.c3{color:red;}）</p></blockquote></li><li>ID选择符：以“#”开始，并可以任意命名。  <blockquote><h1 id="div1-background-red-color-white"><a href="#div1-background-red-color-white" class="headerlink" title="div1{background:red;color:white;}"></a>div1{background:red;color:white;}</h1></blockquote></li><li>伪选择符：一种特殊的类选择符，最大的作用就是对链接\<a>的不同状态定义不同的样式效果  <blockquote><p>   a:link{color:#339999;text-decration:none;}<br>  a:visited{color:#33cc00;text-decration:none}<br>  a:hover{color:red;text-decration:underline;}<br>  a:active{color:blue;text-decration:underline;}<br>  p:first-letter{}<br>  p:first-line{}</p></blockquote></a></li></ol><p>ID选择符与类选择符的区别：<br>（1）类选择符可以给任意多的标记定义样式，但ID选择符在页面中标记中只能使用一次；<br>（2）ID选择符样式比类选择符样式优先级高。ID选择符局限性大，只能单独定义某个元素的样式（特殊情况下使用）。 </p><p>CSS选择器声明：  </p><ol><li>集体声明<br>  h1,h2,h3,h4,h5,h6,p,h2.special,#one{color:red;font-family:黑体;}    </li><li>全局声明 –通配符<br>*{color:purple;font-size:16px;margin:0 auto;padding:0;}  </li><li>派生选择符<br>li strong{ font-style:italic; font-weight:normal;}<br>   strong{font-weight:bold;}  </li></ol><p>CSS样式表类型：4种  </p><ul><li>内联样式表（Inline Style Sheet）&lt;标记 style=”属性: 属性值; 属性: 属性值;…”&gt;  标记本身定义的style优先于其他所有样式定义。  </li><li>内部样式表（Internal Style Sheet）</li><li>链接外部样式表（Link External Style Sheet） <code>&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;外部样式表的文件名称&quot;/ &gt;</code><br><code>&lt;link&gt;</code>标记是单标记，放在头部，不使用style标记。<br>外部样式表的文件名称必须带后缀名.css。<br>CSS文件一定是纯文本格式。<br>外部样式表修改后所有引用的页面样式自动地更新；<br>外部样式表优先级低于内部样式表；<br>同时链接几个外部样式表时按“最近优先的原则”  </li><li>导入外部样式表（Import External Style Sheet）@import url(“外部样式表的文件名称”);<br>@import应该放在style元素的最前面。  </li></ul><p>样式表的继承规则是子标记继承父标记的样式<br>CSS规定样式的优先级(从高到低)如下：<br>      行内样式﹥id样式﹥类样式﹥标记样式  </p><hr><p><strong>图层</strong>是设计网页时用于定位元素或者布局的一种技术，它可以将图层里包含的内容放置到浏览器的任意位置，其包含的内容有：文字、图像、动画甚至是图层。在一个网页文件中可以使用多个图层，图层与图层之间可以重叠，从而图层比表格的布局更加灵活。  </p><p>DIV图层<br><code>&lt;div&gt;&lt;/div&gt;</code>是一个块级(block-level)元素，其前后均有换行符，可定义文档中的分区或节。<br>position:定位，static|absolute|relative |fixed<br>width|:height图层宽度|图层高度<br>left| top:左边距|顶部距离<br>border:边框，“线粗细 线形状 线颜色”<br>z-index:图层层叠，子层永远在父层之上，值越大越在上层,前提条件position属性值为“absolute”。<br>clear:left|right|both|none，清除左、右、两边及允许浮动。<br>float:left|right|none，允许左、右、不浮动。<br>display:block|inline|none, 块显示，行内方式显示，隐藏。  </p><p>图层嵌套，图层层叠。  </p><p>div标记与span标记<br>div和span标记默认情况下都没有对标记内的内容进行格式化或渲染，只有使用CSS来定义相应的样式时才会显示出不同。<br>1)是否是块标记。div标记是块标记，一般包含较大范围，在区域的前后会自动换行；而span标记是行内标记，一般包含范围较窄，通常在一行内，在区域外不会自动换行。<br>2)是否可以互相包含。一般来说，div标记可以包含span标记，但span标记不可能包含div标记。<br>但是块标记和行标记不是绝对的，通过定义CSS的display属性可以相互转化。  </p><p>CSS属性值中的单位  </p><ul><li>绝对单位  </li><li>相对单位<br>经常使用的相对单位包括：em、ex、px、%。  </li></ul><p>font设置综合字体属性<br>font-family设置字体<br>font-size设置字号<br>font-style设置字体样式  normal | italic | oblique<br>font-weight设置字体加粗  normal | bold | bolder | lighter |<br>font-variant设置字体变体  normal | small-caps，用于英文大写  </p><p>text-decoration设置文字效果属性  underline | overline | line-through | none<br>text-indent首行缩进<br>letter-spacing字符间距<br>line-height行距<br>text-transform转换英文大小写 uppercase | lowercase | capitalize[首字母大写]| none<br>text-align水平对齐 left | right | center | justify<br>vertical-align垂直对齐  top|middle|bottom</p><p>颜色color属性<br>color属性用于设置元素字体的色彩，该属性的语法比较简单，但取值比较多样，可以是颜色名称、函数、十六进制数等形式<br>颜色名称<br>使用red、blue、yellow等CSS预定义的表示颜色的参数。CSS预定义17种颜色，如下表所示。<br>RGB()函数<br>使用rgb（RRR, GGG, BBB）或rgb（r%, g%, b%）,字母R或r、G或g、B或b分别表示颜色分量红色、绿色、蓝色，前者参数的取值为0到255，后者参数的取值为0到100。<br>十六进制数<br>使用“#RRGGBB”或者“#RGB”的形式，其中每个位十六进制数从0到F取值，比如#FFC0CB表示pink。  </p><p>背景background属性<br>1.background-color：关键字 |  RGB值 | transparent<br>2.background-image : url(*.jpg) | none<br>3.background-attachment : scroll | fixed<br>4.background-repeat : repeat | repeat-x | repeat-y | no-repeat<br>5.background-position:百分比 | 长度 | 关键字<br>利用百分比和长度来设置图像位置时，都要指定两个值，并且这两个值都要用空格分隔。<br>  关键字在水平方向的主要有left、center、right，<br>  关键字在垂直方向的主要有top、center、bottom。  </p><p>CSS列表样式  </p><ol><li>list-style-type:disc|circle|square|decimal|lower-roman|upper-roman|lower-alpha|upper-alpha|none<br> 对<code>&lt;ol&gt;&lt;ul&gt;</code>列表均有效。  </li><li>list-style-image : url(*.gif)|none  </li><li>list-style-position列表符和列表的相对位置 : inside | outside  </li></ol><p>CSS盒模型<br>盒模型主要定义四个区域MBPC：边界(margin) 、边框(border) 、填充(padding)和内容(content) 。<br>border-width: thin、medium、thick 、length ；复合属性，分border-top-width、border-right-width、border-bottom-width、border-left-width四个子属性。<br>border-style :none|dotted|dashed| solid|double|groove[凹型线］|ridge ［凸型线］ |inset ［嵌入线］ |outset ［嵌出线］;<br>border:边框粗细  边框样式  边框颜色;  </p><p>table属性<br>border-collapse  设置是否把表格边框合并为单一边框 separate|collapse<br>border-spacing  设置分隔单元格边框的距离<br>caption-side 设置表格标题位置<br>empty-cells 是否显示表格中的空单元格<br>table-layout 显示单元，行和列的算法  auto|fixed  </p><hr><p><strong>框架</strong><br>框架技术是一种在一个页面中显示多个网页的技术。<br>框架的基本结构主要分为<strong>框架集</strong>和<strong>框架</strong>两个部分(frameset、 frame)。<br>在HTML文件中，使用框架集的页面<strong>没有body标记</strong><br><code>&lt;frameset&gt;&lt;/frameset&gt; &lt;frame&gt;&lt;/frame&gt;</code><br>框架集设置：<br>frameborder  显示效果  0|1 0不显示边框，1显示边框默认1<br>framespacing<br>border  宽度<br>bordercolor<br>rows 水平分割<br>cols 垂直分割<br>框架设置：<br>指定子窗口显示网页(src)<br>定义子窗口名称 (name)<br>控制子窗口滚动条 (scrolling)  yes|no|auto<br>调整子窗口的尺寸 (noresize)  不赋值表示不允许调整边框尺寸<br>设置子窗口的边距 (marginwidth、marginheight)  </p><p>浮动框架<br> 浏览器窗口含有孤立的子窗口称为浮动框架。在浏览器窗口中使用<code>&lt;iframe&gt;&lt;/iframe&gt;</code>标记，可以嵌入浮动框架。</p><p><strong>表单</strong><br>  <code>&lt;form method=&quot;post&quot; action=&quot;&quot;&gt;</code><br>  <code>&amp;nbsp;\&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;</code><br>  <code>&amp;nbsp;\&lt;taxtarea name=&quot;&quot; rows=&quot;&quot; cols=&quot;&quot; wrap=&quot;&quot;&gt;\&lt;/textarea&gt;</code><br>  <code>&amp;nbsp;\&lt;select name=&quot;&quot; size=&quot;&quot; multiple=&quot;&quot;&gt;</code><br>    <code>&amp;nbsp;&amp;nbsp;\&lt;option value=&quot;&quot; selected&gt;\&lt;/option&gt;</code><br>  <code>&amp;nbsp;\&lt;/select&gt;</code><br>  <code>&lt;/form&gt;</code><br>表单属性：<br>name:给定表单名称，表单命名之后就可以用脚本语言(如JavaScript或VBScript)对它进行控制。<br>action:指定处理表单信息的服务器端应用程序。<br>method:用于指定表单处理表单数据方法，可取值get、post，默认get。<br>enctype:规定表单数据在发送到服务器之前进行编码。有三种取值，分别如如下 ：  </p><ul><li>application/x-www-form-urlencoded (在发送前编码所有字符,默认)   </li><li>multipart/form-data(不对字符编码 )  </li><li>text/plain(空格转换为 “+” 加号，但不对特殊字符编码) 。<br>表单信息：<br>name<br>type text|password|checkbox|radio|image|submit|reset|button|file|hidden<br>value  </li></ul><p>定义域和域标题：<br><code>&lt;fieldset&gt;&lt;/fieldset&gt;</code>定义域<br><code>&lt;legend&gt;&lt;/legend&gt;</code>定义域标题<br><code>&lt;fieldset&gt;&lt;legend&gt;标题&lt;/legend&gt;&lt;/fieldset&gt;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS概念    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CSS（Cascading Style Sheet）层叠样式表，也称为级联样式表，用来设计网页风格   &lt;/li&gt;
&lt;li&gt;在网页制作时采用CSS技术，可以有效地对页面的布局、字体、颜色、背景和其他效果实现更加精确的控制。  &lt;/li&gt;
&lt;li&gt;只要对相应的代码做一些简单的修改，就可以改变同一页面的不同部分，或者不同网页的外观和格式。  &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>html基础</title>
    <link href="http://wangyibo.top/2018/07/03/html%E5%9F%BA%E7%A1%80/"/>
    <id>http://wangyibo.top/2018/07/03/html基础/</id>
    <published>2018-07-03T05:46:21.000Z</published>
    <updated>2018-07-03T06:04:09.257Z</updated>
    
    <content type="html"><![CDATA[<p>HTML文档以<code>&lt;html&gt;</code>标记开始<code>&lt;/html&gt;</code>标记结束。<br>每个HTML文档中有且只有一个HTML，HEAD和BODY标记。<br>一个完整的HTML文档由头部head和主体body两个部分组成。在头部<code>&lt;head&gt;</code>标记中，可定义标题、样式等；在主体<code>&lt;body&gt;</code>标记中，可定义段落、标题字、超链接、脚本、表格、表单等元素，主体内容是网页要显示的信息。<br><br><br><br><br><a id="more"></a></p><h1 id="头部head"><a href="#头部head" class="headerlink" title="头部head"></a>头部head</h1><p><code>&lt;title&gt;浏览器标题上的信息&lt;/title&gt;</code></p><p>元信息meta标记:描述一个HTML网页文档的属性<br><code>&lt;meta name=&quot;&quot; content=&quot;&quot;&gt;</code><br><code>&lt;meta http-equiv=&quot;&quot; content=&quot;&quot;&gt;</code><br>name属性用于描述网页，它是以“名称/值”形式的名称，name属性的值所描述的内容(值)通过content属性表示，便于搜索引擎机器人查找、分类。其中最重要的是description、keywords和robots。<br>http-equiv属性用于提供HTTP协议的响应头报文(MIME文档头)，它是以“名称/值”形式的名称，http-equiv属性的值所描述的内容(值)通过content属性表示，通常为网页加载前提供给浏览器等设备使用。其中最重要的是content-type charset提供编码信息，refresh刷新与跳转页面，no-cache页面缓存，expires网页缓存过期时间  </p><p>样式标记<code>&lt;style&gt;</code> 用于定义样式或导入样式。  </p><pre><code>&lt;style type=&quot;text/css&quot;&gt;       @import url(“mystyle.css”)       p{font-size:24px;color:#FFFFFF;} &lt;/style&gt;</code></pre><h1 id="主体body"><a href="#主体body" class="headerlink" title="主体body"></a>主体body</h1><p>设置body标记属性可以改变Web页面显示效果。body标记主要属性有text、bgcolor、background、link、alink、vlink、topmargin、leftmargin。  </p><h1 id="HTML文档编写规范"><a href="#HTML文档编写规范" class="headerlink" title="HTML文档编写规范"></a>HTML文档编写规范</h1><ol><li>所有标记均以“&lt;”开始、以“&gt;”结束。 </li><li>根据标记类型，正确输入标记，单标记最好在右尖括号前加1个斜杠“/”，如换行标记是单标记<br>，双标记最好同时输入起始标记和结束标记，以免忘记。</li><li>标记可以嵌套使用，但不能交叉使用。 </li><li>在HTML代码中不区分大小写。</li><li>标记中属性值建议用双引号标注起来 </li><li>书写开始与结束标记时，在左尖括号与标记名或与斜杠“/”之间不能留有多余空格，否则浏览器标记不能识别，导致错误标记直接显示在页面上，影响页面美观效果。 </li><li>编写HTML代码时，应该使用锯齿结构，即采用缩进风格，使代码结构清晰。</li></ol><h1 id="HTML文档类型"><a href="#HTML文档类型" class="headerlink" title="HTML文档类型"></a>HTML文档类型</h1><p><code>&lt;!DOCTYPE&gt;</code>标记<br>基本语法<br>    <code>&lt;!DOCTYPE element-name DTD-type DTD-name DTD-url&gt;</code><br>语法说明<br>    <code>&lt;!DOCTYPE &gt;</code>表示开始声明DTD（Document Type Definition文档类型定义），其中DOCTYPE是关键字。<br>HTML 4.01 规定了三种DTD类型：严格Strict、过渡Transitional以及框架Frameset</p><p>Web页面设计需要遵循设计的3C原则：简洁, 一致性，好的对比度  </p><h1 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h1><p>标题<code>&lt;h1&gt; - &lt;h6&gt;</code><br>字体<code>&lt;font  face=&quot;&quot;  size=&quot;&quot;  color=&quot;&quot; &gt;&lt;/font&gt;</code><br>段落<code>&lt;p&gt;&lt;/p&gt;</code><br>换行<code>&lt;br&gt;</code><br>水平分割线<code>&lt;hr size=&quot;&quot;  color=&quot;&quot;   width=&quot;&quot;  align=&quot;&quot;    &gt;</code><br>内容居中<code>&lt;center&gt;&lt;/center&gt;</code><br>段落缩进<code>&lt;blockquote&gt;&lt;/blockquote&gt;</code>   一对blockquote标记能够向右缩进5个西方字符的位置<br>预格式化标记<code>&lt;pre&gt;&lt;/pre&gt;</code> 标记对网页中的文字段落进行预格式化，浏览器会完整保留设计者在源文件中所定义的格式，包括各种空格、缩进以及其他特殊格式。   </p><p>无序列表<code>&lt;ul type=&quot;disc | circle | square&quot;&gt;&lt;/ul&gt;</code><br>disc - ●； circle -○； square -■<br>菜单列表<code>&lt;menu&gt;&lt;/menu&gt;</code><br>目录列表<code>&lt;dir&gt;&lt;/dir&gt;</code><br>有序列表<code>&lt;ol type=&quot;1| A | a | I | i &quot; start=&quot;2&quot; &gt;&lt;/ol&gt;</code><br>列表项<code>&lt;li&gt;&lt;/li&gt;</code> </p><p>定义列表<code>&lt;dl&gt;&lt;/dl&gt;</code><br><code>&lt;dt&gt;&lt;/dt&gt;</code> <code>&lt;dd&gt;&lt;/dd&gt;</code><br>dt标记的由来:definition term<br>dd标记的由来: definition description   </p><p>超链接<code>&lt;a href=“url” name=“” title=“提示信息” target=“窗口名称”&gt;超链接标题&lt;/a&gt;</code><br>target：指定打开的目标窗口 。有5 种取值：<br> _parent -上一级窗口；_blank-新窗口；framename-框架名<br> _self - 同一窗口，默认值；_top - 整个窗口打开  </p><p><strong>超链接</strong>是指从一个网页指向一个目标的连接关系。目标可以是：一个网页、图片、一个电子邮件地址、一个文件或是一个应用程序<br>超链接可以分为<strong>内部链接</strong>和<strong>外部链</strong>接两种  </p><p>书签链接 书签是指到文章内部的链接，可是实现段落间的任意跳转。实现这样的链接要先定义书签名称和书签链接。<br><code>&lt;a name=&quot;name&quot;&gt;书签标题&lt;/a&gt;</code><br><code>&lt;a href=&quot;#name&quot;&gt;书签标题&lt;/a&gt;</code>        同一页面内<br><code>&lt;a href=&quot;URL#name&quot;&gt;书签标题&lt;/a&gt;</code>     不同页面间   </p><p>图像链接<code>&lt;a href=“http://www.163.com”&gt;&lt;img src=“url” width=“” height=“” hspace=“” vspace=“” align=“” border=“” alt=“”&gt;&lt;/a&gt;</code><br>图像热区链接<code>&lt;img src=&quot;图片地址&quot; usemap=&quot;#映射图片名称&quot;&gt;</code><br><code>&lt;map name=&quot;映射图片名称&quot;&gt;</code><br>      <code>&lt;area  shape=&quot;热区形状&quot; coords=&quot;热区坐标&quot; href=&quot;URL&quot;&gt;</code><br><code>&lt;/map&gt;</code><br>其中： shape:rect(矩形)、 circle (圆形)、 poly (多边形) ；<br>            coords与shape对应的坐标值：<br>            rect： x1,y1,x2,y2 (4 个值);<br>            circle ： center-x、center-y、radius(3个值)<br>            poly ：（ x1,y1,x2,y2 ,…,xi,yi,…,xn,yn,x1,y1）(（n+1）*2个值，多边形的顶点数)。  </p><p>电子邮件链接<code>&lt;a href=“mailto:E-mail地址[ ?subject=邮件主题[&amp;参数=参数值]]”&gt;链接内容&lt;/a&gt;</code>    </p><p>图像<code>&lt;img **src**=“url” alt=&quot;&quot;&gt;&lt;/img&gt;</code><br><strong>src</strong>(source):图像的 URL路径(相对路径、绝对路径)。<br><strong>alt</strong> ：添加图片的替代文字<br>width/height：设置图片的宽度和高度(px,%)<br>border：设置图片边框(px)<br>align ：设置图片对齐方式（水平/垂直两个方向）<br>hspase/vspase ：设置图片的间距设置(单位不加px)<br>align : 图片对齐方式<br>hspace ：定义图像左侧和右侧空白<br>vspace ： 定义图像顶部和底部空白<br>usemap ： 定义热区  </p><p>滚动文字<code>&lt;marquee&gt;&lt;/marquee&gt;</code><br>bgcolor：滚动文字背景颜色<br>direction：设置滚动方向(<strong>left</strong>/right/ up/down)<br>behavior：设置滚动方式(<strong>scroll</strong>/slide/alternate) (循环往复滚动，为默认值/滚动一次就停止/来回交替滚动)<br>scrollamount：设置滚动速度(px)<br>scrolldelay：设置滚动延迟(ms)  设置越小滚动越快<br>width/height：设置滚动范围<br>hspace/vspace：设置滚动空白空间<br>loop：设置滚动循环，-1：表示无限滚动。   </p><p>背景音乐<code>&lt;bgsound&gt;</code><br>src：背景音乐文件的地址或文件名称（带后缀）。<br>loop：播放的次数，用数字表示。正整数表示播放指定次数，infinite和-1表示播放无限次数，直到关闭浏览器为止。   </p><p>插入音频、视频及 Flash<code>&lt;embed&gt;&lt;/embed&gt;</code><br>src<br><strong>width、height</strong>：单位为像素，必须设置，否则不显示播放界面，无法控制；<br>autostart的取值有两个：一个是true，表示自动播放；另一个是false，表示不自动播放；<br>loop表示是否循环 。true:表示循环；false:表示不循环。  </p><p>表格<code>&lt;table&gt;&lt;/table&gt;</code><br>表格标题<code>&lt;caption&gt;&lt;/caption&gt;</code><br>表头<code>&lt;th&gt;&lt;/th&gt;</code>  table head<br>行<code>&lt;tr&gt;&lt;/tr&gt;</code>  table row<br>列<code>&lt;td&gt;&lt;/td&gt;</code>  table data<br>定义表格的表头<code>&lt;thead&gt;&lt;/thead&gt;</code><br>定义表格的主体<code>&lt;tbody&gt;&lt;/tbody&gt;</code><br>定义表格的页脚<code>&lt;tfoot&gt;&lt;/tfoot&gt;</code></p><p>表格属性：<br>algin left|center|right<br>bgcolor<br>border  表格边框宽度<br>cellpadding  规定单元边沿与其内容之间的空白<br>cellspacing  规定单元格之间的空白<br>frame  规定外侧边框哪部分可见  above|below|hsides|vsides|lhs|rhs|border|void<br>rules  规定内侧边框哪部分可见  none|all|rows|cols|groups<br>height<br>width  </p><p>表格行属性：<br>align<br>valign<br>bgcolor<br>bordercolor<br>bordercolorlight  左上颜色<br>bordercolordark   右下颜色  </p><p>单元格属性：<br>rowspan  单元格跨行<br>colspan 单元格跨列  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML文档以&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;标记开始&lt;code&gt;&amp;lt;/html&amp;gt;&lt;/code&gt;标记结束。&lt;br&gt;每个HTML文档中有且只有一个HTML，HEAD和BODY标记。&lt;br&gt;一个完整的HTML文档由头部head和主体body两个部分组成。在头部&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;标记中，可定义标题、样式等；在主体&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;标记中，可定义段落、标题字、超链接、脚本、表格、表单等元素，主体内容是网页要显示的信息。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>早安！ 公主！</title>
    <link href="http://wangyibo.top/2018/06/17/%E7%BE%8E%E4%B8%BD%E4%BA%BA%E7%94%9F/"/>
    <id>http://wangyibo.top/2018/06/17/美丽人生/</id>
    <published>2018-06-17T06:15:23.000Z</published>
    <updated>2018-06-18T04:25:23.458Z</updated>
    
    <content type="html"><![CDATA[<p>《美丽人生》是一部由罗伯托·贝尼尼执导，罗伯托·贝尼尼、尼可莱塔·布拉斯基、乔治·坎塔里尼等人主演的剧情片。1997年12月20日，该片在意大利上映。<br>1999年，该片在第71届奥斯卡奖获得了最佳外语片、最佳男主角、最佳配乐三项奖项。<br>该片始终保持有趣的基调，面对纳粹这样残酷的境况。<br>在不致郁的情况体了纳粹的残酷，体现了基督的勇敢机智，以及责任感。  </p><a id="more"></a><h2 id="早安-公主"><a href="#早安-公主" class="headerlink" title="早安 公主"></a>早安 公主</h2><p>当朵拉掉从空中掉到基督的怀里的时候，早安公主。<br>当基督骑车摔到朵拉怀里的时候，早安公主。<br>当在集中营中为了让朵拉放心，早安公主。  </p><p>面对朵拉，他机智勇敢，称朵拉为公主。<br>当他听到朵拉要结婚后，他目光呆滞，行为愚钝。<br>而当在桌子底下，朵拉亲吻了他，并告诉他“带我走吧”后，瞬间眼睛炯炯有神。<br>基督的执行力很强，随后就带着朵拉走了，在座的来宾根本来不及反应，还有鼓掌的。  </p><p>基督又一个想法时，他就会做，并没有太多的等待。<br>而现在的社会，有很多人只有想法，却不肯去做，不去实现。<br>总有大量的借口，拖延，总想着以后。<br>结果就是没有。  </p><p>我想起去吃校门口的麻辣拌，那个叔叔说的话。<br>“我要下学期要弄在网上卖，不通过美团那些app，自己搞，这个就是我一开始的目标，我本来是要在门口摆上一年，随后便推出外卖的，上一学期都谈好了，结果那个人突然变卦，所以一直推迟。而下一学期我一定要弄好，有想法为什么不能实现呢？”<br>确实有想法为啥不去做呢？  </p><p>之后他们有了孩子，叫乔舒亚。<br>基督骑着车送朵拉上班，送乔舒亚上学，欢声笑语起了无穷。  </p><p>但时局动荡，犹太人被抓了，基督和乔舒亚被抓了。  </p><h2 id="让我上火车"><a href="#让我上火车" class="headerlink" title="让我上火车"></a>让我上火车</h2><p>朵拉知道自己的丈夫和孩子被抓走。<br>于是便找到了送他们去集中营的火车，对这里的军官说“让我上火车”。  </p><p>这里的军官时拒绝的，她不是犹太人。<br>但“让我上火车”。她的目光时如此的坚毅，没有丝毫的犹豫。<br>仿佛今年世界杯上C罗在87分钟发任意球一样，眼神坚毅充满杀气。  </p><p>于是她上了火车。<br>衣着整齐，气宇轩昂，走上了开往集中营的火车。  </p><p>她知道集中营中会发生什么，但依旧愿意和丈夫和孩子在一起，这大概就是爱吧。  </p><h2 id="这是一场游戏"><a href="#这是一场游戏" class="headerlink" title="这是一场游戏"></a>这是一场游戏</h2><p>他们被抓去了集中营。<br>一路上基督都在表现的很开心，告诉自己的孩子，这是一场旅行。<br>可以坐火车，但火车只能站着没有座位。 </p><p>我记得一本书叫《爸爸，我们去哪呀》，作者有两个孩子，都是残障儿。<br>他在里面说：“我们都希望与众不同，看我实现了”。充满了无奈。  </p><p>这里也有心酸吧，叶也说总感觉他笑着笑着就哭出来了。  </p><p>之后他们到达了集中营，基督告诉他儿子，这是一场游戏。<br>所有人都是谁先到达1000分，谁就可以得到奖品，奖品是乔舒亚最喜欢的坦克。  </p><p>乔舒亚一只听爸爸的话，以为这就是一场游戏，并为了收集1000分而努力听话。<br>基督每次从外面回来都兴致满满，告诉儿子今天有多少分，并鼓励儿子。  </p><p>后来德国战败，他们做最后的挣扎，要再杀一些犹太人。<br>基督担心朵拉上车被杀。<br>先将自己的儿子藏到了柜子里，化装成女的去找朵拉。<br>并没有在车上找到朵拉，他被抓住。<br>在经过他儿子面前时，他仍然一副开心的样子。<br>之后被枪杀了。  </p><h2 id="我们赢了"><a href="#我们赢了" class="headerlink" title="我们赢了"></a>我们赢了</h2><p>天亮了，德国人都走了。<br>乔舒亚从柜子里走出来了，真的见到了坦克了，并做上了坦克。<br>在路上乔舒亚看到了妈妈，和妈妈相遇了。<br>他们大喊我们赢了，而这时乔舒亚仍然认为这是一场游戏。  </p><h2 id="美丽人生"><a href="#美丽人生" class="headerlink" title="美丽人生"></a>美丽人生</h2><p>究竟谁的人生是美丽的？<br>为什么这部影片叫做美丽人生？<br>其实我并没有明确的想法。<br>朵拉有基督，基督有朵拉，乔舒亚有朵拉，有基督。<br>朵拉遇见了基督，基督遇见了朵拉。<br>乔舒亚在游戏中度过了可能时人生中最艰苦的几年。<br>嗯，还是不清楚。  </p><p>聪明的你，有答案了吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《美丽人生》是一部由罗伯托·贝尼尼执导，罗伯托·贝尼尼、尼可莱塔·布拉斯基、乔治·坎塔里尼等人主演的剧情片。1997年12月20日，该片在意大利上映。&lt;br&gt;1999年，该片在第71届奥斯卡奖获得了最佳外语片、最佳男主角、最佳配乐三项奖项。&lt;br&gt;该片始终保持有趣的基调，面对纳粹这样残酷的境况。&lt;br&gt;在不致郁的情况体了纳粹的残酷，体现了基督的勇敢机智，以及责任感。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://wangyibo.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="影评" scheme="http://wangyibo.top/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>太白山之行</title>
    <link href="http://wangyibo.top/2018/06/11/%E5%A4%AA%E7%99%BD%E5%B1%B1%E4%B9%8B%E8%A1%8C/"/>
    <id>http://wangyibo.top/2018/06/11/太白山之行/</id>
    <published>2018-06-11T01:56:30.000Z</published>
    <updated>2018-06-12T04:50:06.351Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/06/11/太白山之行/travel/taibai1.jpg" width="600"></p><p>六月登太白，一些愉快的记忆  </p><a id="more"></a><p>古人云：“智者乐水，仁者乐山。”我没有此等文人雅士之情怀。<br>只想带着我喜欢的的人，爬爬山，赏赏景。<br>在这山水之间，感知大自然的美好，随路途遥远，艰辛，但一路坚持，美景无数，佳人在伴，不枉此行。  </p><h2 id="西上太白峰，夕阳穷攀登"><a href="#西上太白峰，夕阳穷攀登" class="headerlink" title="西上太白峰，夕阳穷攀登"></a>西上太白峰，夕阳穷攀登</h2><p>心心念念太白山了好久，终于可以一览太白山的英姿了。  </p><p>我和叶一大早，就从杨凌出发前往了太白山。<br>一上车就犯困的我，睡着了。<br>我们到达了太白山游客服务中心，哇，人超多的，本想着不是节假日，人会少些。<br>我们在人群中被挤来挤去，不过还是很快的买到了票。  </p><p>又坐上了前往山里的车，到达了莲花峰瀑布。<br><img src="/2018/06/11/太白山之行/travel/taibai2.jpg" width="600"><br>面对如此美景，我也就只能说出一个<strong>美</strong>而已。<br>而文人雅士却可  </p><blockquote><p>豁开青冥巅，泻出万丈泉，如裁一条素，白日悬秋天  </p></blockquote><p>在此处还有三国古栈道，又称鸟道，李白有诗云：“西当太白有鸟道，可以横绝峨眉巅。”<br>经过着1100米长的古栈道，我们到了泼墨山。<br><img src="/2018/06/11/太白山之行/travel/taibai3.jpg" width="600"><br>相传唐代大诗人李白到此触景生情，卧石畅饮太白美酒，岂料“举目山水皆是景，诗到多时苦难吟；抛笔飞砚入云端。留下千古泼墨痕”。 至今墨迹未干，人称泼墨山。 </p><p>而后，我们又进过了“水佛寺”（那个司机口中所说，实则睡佛寺）。<br>在山间行走，吹山间凉风，树林阴翳，鸣声上下。<br>野芳发而幽香，佳木秀而繁阴。<br>怎一个“爽”字了得。<br><img src="/2018/06/11/太白山之行/travel/taibai4.jpg" width="600">  </p><p><img src="/2018/06/11/太白山之行/travel/taibai5.jpg" width="600"> </p><p><img src="/2018/06/11/太白山之行/travel/taibai6.jpg" width="600"><br>缘溪行，忘路之远近。忽逢世外桃源。<br>走近一瞧，有一洞，仿佛有光，从口入，才通人，行几步，豁然开朗。<br>别有洞天。  </p><h2 id="太白与我语，为我开天关"><a href="#太白与我语，为我开天关" class="headerlink" title="太白与我语，为我开天关"></a>太白与我语，为我开天关</h2><p>到达了天下索道，风景不再是前面那样，开始慢慢的开朗。<br>前面所观好比那种温柔委婉的女子。<br>如今所看好比大气磅礴的男子。  </p><p>乘索道，观远山。<br><img src="/2018/06/11/太白山之行/travel/taibai7.jpg" width="600"><br>随着海拔的升高，植被也开始有所变化了。<br><img src="/2018/06/11/太白山之行/travel/taibai8.jpg" width="600">  </p><p>到达天圆地方，这里已经是海拔3511米。<br>极目远眺，重峦叠嶂。<br>蔚蓝的天，雪白的云，青翠的山。<br>三种颜色混合，构成一幅不需要任何修饰的美丽景象。<br><img src="/2018/06/11/太白山之行/travel/taibai9.jpg" width="600">  </p><p>我和叶在人群中穿梭，上蹦下跳的走着。<br>完全不知道之后的路对于我们来说是有多么难走，多么费劲。<br><img src="/2018/06/11/太白山之行/travel/taibai10.jpg" width="600"><br><img src="/2018/06/11/太白山之行/travel/taibai11.jpg" width="600">  </p><p>第四纪冰川遗迹横亘在我们面前，我们要走4.4公里如此的路才能到达大文公庙。<br><img src="/2018/06/11/太白山之行/travel/taibai12.jpg" width="600"><br>在小文公庙进行登记的时候我们遇见了一个女孩子，和一队情侣，他们都超厉害的。<br>我们在手拉着手一路前行，内心充满了希望。<br>在着充满石头路上，开着许多杜鹃花，甚是美丽。<br>我们一路上被别人说凉凉，他们发现我们穿的甚少，各种劝退我们。<br>可能我们真的没有领略过山顶之冷，对他们的劝退不予理睬。<br>依旧前行。  </p><p>到达大文公庙了，这里手机已经没了信号，然而我们并不知道。<br>依旧傻乐着。<br>接着我们继续向前，前往大爷海。<br>我们已经看到了山上的雪，并不断的向那进发。<br>气温也慢慢的凉了下了，不过牵着你的手，我丝毫没有凉意，还有一丝小热。<br>这一段路程是我们第一天前行中最难的路程。<br><img src="/2018/06/11/太白山之行/travel/taibai14.jpg" width="600"> </p><p>这段路程中我们要经历三个巨大的爬坡，好陡的。<br>我们速度还不能太慢，我们需要加快脚步，前往大爷海住宿的地方抢占一个床位。<br>人超级多，晚了可能就得坐着过一晚上啦。  </p><p>在床的驱使下，我们在慢中求超。<br>学习乌龟，走的慢，歇的少。<br>然后我们就超过了许多人。  </p><p><strong>心疼我的叶儿，她好厉害的，超级棒。</strong><br>看她的小表情，超级萌的。<br><img src="/2018/06/11/太白山之行/travel/taibai13.jpg" width="600">  </p><p>终于我们到达了大爷海。<br><img src="/2018/06/11/太白山之行/travel/taibai15.jpg" width="600">  </p><h2 id="愿乘泠风去，直出浮云间"><a href="#愿乘泠风去，直出浮云间" class="headerlink" title="愿乘泠风去，直出浮云间"></a>愿乘泠风去，直出浮云间</h2><p><img src="/2018/06/11/太白山之行/travel/taibai16.jpg" width="600"><br>人果真超级多，我们一心想着区订张床。<br>这时候才猛然意识到，没有手机信号。<br>现金也没有带够，没有什么办法，只好向一同订房的人借些许的钱。<br>我们成功的订到了床位，哈哈。  </p><p>于是我们想出去走走，并想办法联系下家人，毕竟感觉我们像失联了一样。<br>在我们的搜寻下，猛然发现联通的手机有时会有一点信号。<br>抓住这个机遇，联系的到了家里，报了波平安。  </p><p>不过外面是真的冷呀。<br>我们真是穿的少了，被寒冷赶回床上。<br>我和叶儿睡在了一起。<br>嗯，一个被子里诶，小开心，小激动。  </p><p>在被子里我慢慢的就暖和了起来。<br>然而我的叶儿，却是个冰雪美人。<br>手脚冰凉，我就慢慢的暖着她。  </p><p>在这里我们发现，睡觉还是有些艰难的。<br>我们感觉睡了好久，起码四五个小时了呀。<br>起来一看表二十分钟。<br>哈？心态哈哈。  </p><p>夜里我们乘着冷风起来看了一眼夜空。<br>好多的星星呀，我从未见过如此多的星星。<br>而且北斗七星是如此的明显。<br>但冷风依旧，我们又被吹了回去。<br>不知古人爬山的时候，衣服带够了吗？<br>心疼他们一波。  </p><p>我们意识到这个残酷的现实。<br>决定放弃去看日出，等太阳出来后在完成我们的登顶。  </p><p>早上起来，我们吃了点面包，开始了我们的登顶。  </p><h2 id="举手可近月，前行若无山"><a href="#举手可近月，前行若无山" class="headerlink" title="举手可近月，前行若无山"></a>举手可近月，前行若无山</h2><p>我们仿佛又一种属性——不认路。<br>跟着前面的人，走到了一条捷径。<br>全是石头，只能手脚并用的向上爬，于是我们成功的挂到了山上。<br><img src="/2018/06/11/太白山之行/travel/taibai17.jpg" width="600"> </p><p>终于从碎石阵里一路滑下来，到了一条平缓的路上了。<br>经过这条路，我们可以看见二爷海和三爷海。<br>跟大爷海比起来，他们逊色了很多。<br>毕竟“你大爷还是你大爷”。  </p><p>走这条路慢慢的走到了山顶，已经可以看见拔仙台了。<br>结果让她给吃掉了，哼，吃货。<br><img src="/2018/06/11/太白山之行/travel/taibai18.jpg" width="600">  </p><p>到了拔仙台了，开心。<br>真的有一种前行若无山的体验。<br>坐在拔仙台上，我们啃了苹果，真好吃。<br><img src="/2018/06/11/太白山之行/travel/taibai19.jpg" width="600">  </p><p><img src="/2018/06/11/太白山之行/travel/taibai20.jpg" width="600"></p><p><img src="/2018/06/11/太白山之行/travel/taibai21.jpg" width="600">  </p><h2 id="何时复见还"><a href="#何时复见还" class="headerlink" title="何时复见还"></a>何时复见还</h2><p>开始返程了，我们返程的路上又欣赏了来时的因为着急错过的风景。<br><img src="/2018/06/11/太白山之行/travel/taibai22.jpg" width="600">  </p><p><img src="/2018/06/11/太白山之行/travel/taibai23.jpg" width="600"></p><p><img src="/2018/06/11/太白山之行/travel/taibai24.jpg" width="600">  </p><p>虽然依旧累，但我们超级棒，还是在规定的时间内走了出来。<br>看见了平地，从未如此兴奋过。  </p><p>乘索道下行，遇到以为同学科大佬，他一天就爬完了太白山。<br>嗯，厉害。  </p><p>回到了学校，吃了麻辣烫，喝了冰峰，好吃，好喝。  </p><p>开心<del>~</del>~  </p><hr><p>以后爬山，得做好防晒措施呀，否则就被晒红了呀。<br>而且现金得多带。<br>水要多带。  </p><p>宋代禅宗大师青原行思提出参禅的三重境界：<br>参禅之初，看山是山，看水是水；<br>禅有悟时，看山不是山，看水不是水；<br>禅中彻悟，看山仍然山，看水仍然是水。  </p><p>我看山是山，看水是水，它就是那么美呀。  </p><p>不过真的是经历太少，读书太少，思考太少，所以还是这么浅薄。<br>脑子里都是空的，一敲尽是回声。  </p><p>一路上也遇到许多人，他们热情，活泼，我们受过他们的许多帮忙与提醒。<br>他们使得我们上山的路简单，使得我们充满信心与希望。<br>在这样的路上磨练过后，知道前方艰难，总希望别人可以少走弯路，可以坚持下去，可以完成目标。 </p><p>在一路上我们一起前行，互相搀扶，终得胜利。<br>陪伴可能真的是最长情的告白吧。  </p><p>愿好。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/06/11/太白山之行/travel/taibai1.jpg&quot; width=&quot;600&quot;&gt;&lt;/p&gt;
&lt;p&gt;六月登太白，一些愉快的记忆  &lt;/p&gt;
    
    </summary>
    
    
      <category term="游记" scheme="http://wangyibo.top/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="随笔" scheme="http://wangyibo.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>机器人总动员——你是我的eva吗</title>
    <link href="http://wangyibo.top/2018/06/03/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%80%BB%E5%8A%A8%E5%91%98%E2%80%94%E2%80%94/"/>
    <id>http://wangyibo.top/2018/06/03/机器人总动员——/</id>
    <published>2018-06-03T07:58:01.000Z</published>
    <updated>2018-06-11T02:06:17.920Z</updated>
    
    <content type="html"><![CDATA[<p>有一个多月没有回家了，终于这周可以回家啦。<br>结果没赶上高铁，只能重新买票，然而又得等一个小时，又遇到高铁晚点87分钟，没得办法，只得和叶在车站看电影了。<br>于是我们就看了《机器人总动员》这部电影。<br>这部电影几乎没有台词，对话，但却通过walle和eve之间的动作，小表情表现出胜于对话方式的感觉。理解起来完全没有丝毫问题。<br><img src="/2018/06/03/机器人总动员——/movie/walle2.jpg" width="600"><br><a id="more"></a>  </p><p>这部电影2008年由皮克斯动画制作室制作，华特·迪斯尼电影公司负责发行。<br>故事讲述了地球上的清扫型机器人walle偶遇并爱上eve后，追随她进入太空的一系列故事，获得第81界奥斯卡最佳动画长篇奖。  </p><p>影片开始出现在地球上，整个地球上充满了垃圾，在这些垃圾中，有一个特别的存在，那就是walle。<br>他是一只垃圾清扫机器人，浑身脏兮兮的，而且机身破旧，与他的宠物小强相依为伴。<br>白天，他在清理垃圾中，顺便给自己寻找有可以回收的资源，带回自己的小窝。<br>夜里，他在自己的小窝中，观看收集来的磁带，人类的爱情，他也渴望自己的爱情。  </p><p>有一天，来了一个巨大的飞船，从飞船上放下了一个机器人，eve。<br>她是一个光滑精巧而且还会飞行的探测机器人，她的目的是寻找地球上的植物，以确定人类是否可以生存。  </p><p>他们就这样相遇了，walle一直想要接近eve，然而eve有任务在身，对walle一直特别高冷。</p><p>终于一天，walle有机会和eve交流了，他们互相介绍，然而walle却把eve叫成eva<br>沙城暴来了，walle把eva拉回的了自己的小窝，向她展示了自己收集的种种欢乐，eva也玩的很开心。<br>walle想要牵住eva的小白手，结果被高冷的拒绝了。<br>最后walle给eva展示了收集的一株植物，eva看到之后，将植物收到自己的肚子中进入了待机状态。<br><img src="/2018/06/03/机器人总动员——/movie/walle1.jpg" alt=""></p><p>walle以为eva没电了，尝试了各种办法，想要唤醒eva，最终都以失败告终。<br>最后他单方面的进行了一次约会，牵着eva的小白手，看着夕阳。<br><img src="/2018/06/03/机器人总动员——/movie/walle3.jpg" alt=""></p><p>他又出去收集垃圾，不过是垂着头，丧着气。  </p><p>那个巨大的飞船回来了，带走了eva。<br>walle也追了上去，趴在了飞船的外面。  </p><p>他一路追随者eva，保护者她，当eva的植物不见了，船长下令把eva送去检查，顺便把walle送去清理。<br>walle透过玻璃，看到eva，以为eva被欺负，于是就冲了进去，结果释放了一堆有问题的机器人。<br>而且也使得eva成了危险机器人，被通缉。  </p><p>eva想要把walle送回地球，结果发现了那株植物，在返回舱里。<br>walle刚拿到植物，返回舱发射了，而且同时开启了自爆程序。<br>eva也紧跟着冲了出去，当她看到了返回舱爆炸，顿时非常难过。<br>但walle靠着灭火器逃了出来，还带回了植物，他们开始了在太空充满活力的dancing，非常的美丽。<br><img src="/2018/06/03/机器人总动员——/movie/walle4.jpg" alt=""> </p><p>他们把植物送回飞船，也经历了许多磨难。<br>eva在飞船中看到了自己待机时，walle所做的一切，仿佛明白了爱，默默的合起了自己的小白手。<br>但他们收到了ai的阻止。<br>walle的芯片被毁坏了，eva也被进入的到了关机状态，一起扔到了垃圾堆。<br>在垃圾堆中，eva寻找了许多芯片但没有可以使用的。<br>这时eva向walle伸出了小白手，但walle想要她会地球。<br>于是他们在大家的帮助下，战胜了ai，回到了地球。<br>在地球上eva用最快的速度修好了walle，但walle好像什么都不记得了。<br>她用了许多办法，最终，她牵着他的手，以机器人的亲吻方式唤醒了walle。  </p><p>整部影片给我以一种独特的温馨，与令人舒适的感觉。<br>walle与eva的各种萌态。<br>walle为了eva做出的种种。<br>虽然有一些小小的设计上的bug，但不影响这部影片表达最存粹的爱恋，将人类特有的感情融入到了机器人中，依旧是那么的甜。  </p><p>嗯，我也有我的eva诶。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一个多月没有回家了，终于这周可以回家啦。&lt;br&gt;结果没赶上高铁，只能重新买票，然而又得等一个小时，又遇到高铁晚点87分钟，没得办法，只得和叶在车站看电影了。&lt;br&gt;于是我们就看了《机器人总动员》这部电影。&lt;br&gt;这部电影几乎没有台词，对话，但却通过walle和eve之间的动作，小表情表现出胜于对话方式的感觉。理解起来完全没有丝毫问题。&lt;br&gt;&lt;img src=&quot;/2018/06/03/机器人总动员——/movie/walle2.jpg&quot; width=&quot;600&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://wangyibo.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="影评" scheme="http://wangyibo.top/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>楚门的世界</title>
    <link href="http://wangyibo.top/2018/05/24/%E6%A5%9A%E9%97%A8%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://wangyibo.top/2018/05/24/楚门的世界/</id>
    <published>2018-05-23T16:39:17.000Z</published>
    <updated>2018-06-11T02:07:31.187Z</updated>
    
    <content type="html"><![CDATA[<p><strong>In case I don’t see you, good morning, good afternoon and good night.</strong></p><p><img src="/2018/05/24/楚门的世界/movie/trumen.jpg" width="600"></p><a id="more"></a> <p>这是我在看《楚门的世界》中印象最深的一句话，在影片一开头，楚门便对邻居说了这句话，在影片的结尾，楚门对者屏幕前的所有观看者，说出了这句话。<br>此话在影片开头，有一种很开心见到你，祝你一切安好，在结尾我感觉到，我的演出到此结束，我要去追寻我所向往的，当然祝你在见不到我的日子里，早安，午安，晚安。  </p><p>楚门在影片中是一个肥皂剧的主角，然而他并不知道，自己的一举一动，都被播出，被17亿人所观看，并且在他身边的人都是演员，而他就这样在一个非常巨大的摄影棚中生活了30年。<br>最终他发现了，周围的一切，妻子在与他亲吻的照片上，叠了指头；妻子会时不时的开始念广告词；街上的行人，绕着街道转着圈圈；他想要逃离这里，但受到的重重阻碍，他想去斐济，去见那个女生，那个他忘不了的女生，那个告诉他周围一切都是虚假的女生哪里去。<br><img src="/2018/05/24/楚门的世界/movie/trumen2.jpg" alt="">  </p><p>他克服了怕海的缺限，乘着小船逃离，当然过程也是艰难的，这部肥皂剧的导演竭尽全力的去阻止他，甚至想把他杀死，但他不惧，将自己与船绑在一起。<br><img src="/2018/05/24/楚门的世界/movie/trumen3.jpg" alt=""><br><img src="/2018/05/24/楚门的世界/movie/trumen4.jpg" alt=""></p><p>最终他战胜了巨大的风浪走到了，这个世界的尽头，他摸到的了这个世界的边界，走上了台阶打开了门。</p><blockquote><p>TRUMAN:Who are you?</p><p>TRUMAN:And who am I?</p><p>CHRISTOF:I am the creatorof a television show that gives hope and joy and inspiration to millions.</p><p>CHRISTOF: You’re the star.</p><p>TRUMAN:Was nothing real?</p><p>CHRISTOF:YOU were real. That’s what made you so good to watch. Listen to me, Truman. There’s no more truth out there than there is in the world I created for you. Same lies. The same deceit. But in my world, you have nothing to fear. I know you better than you know yourself.</p><p>TRUMAN:You never had a camera in my head!</p><p>CHRISTOF:You’re afraid. That’s why you can’t leave. It’s okay, Truman. I understand. I have been watching you your whole life. I was watching when you were born. I was watching when you took your first step. I watched you on your first day of school. heh heh. The episode when you lost your first tooth. heh heh heh. You can’t leave, Truman. You belong here…With me. Talk to me. Say something. ‘ell, say something, goddamnit! You’re on television! You’re live to the whole world!</p><p>TRUMAN:In case I don’t see ya’, good afternoon, good evening and goodnight. Hahaha! Yeah!  </p></blockquote><p><img src="/2018/05/24/楚门的世界/movie/trumen.jpg" alt=""><br>这是他们最后的对话，楚门在说完最后一句话后，鞠躬，谢幕，走向了另一个世界。  </p><p>我知道，我所生活的世界，存在着谎言，欺骗，在这个世界，我并不是一直是安全的，我需要考虑种种状况，但这个世界有我向往的<strong>一些真实</strong>，有人真心爱我，有人真心关心我，我也有真心所爱的人。  </p><p>可以为了理想去奋斗，最后光彩的谢幕。对这个世界说上一句：<strong>In case I don’t see you,good morning，good afternoon and good night.</strong>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;In case I don’t see you, good morning, good afternoon and good night.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/05/24/楚门的世界/movie/trumen.jpg&quot; width=&quot;600&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://wangyibo.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="影评" scheme="http://wangyibo.top/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://wangyibo.top/2018/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://wangyibo.top/2018/05/20/操作系统/</id>
    <published>2018-05-20T02:13:13.000Z</published>
    <updated>2018-05-27T14:50:13.266Z</updated>
    
    <content type="html"><![CDATA[<p>上一次对<strong>面向对象设计与分析</strong>进行了总结，没有采用<strong>思维导图</strong>的方式，此次对计算机操作系统的总结采用思维导图的方式，来进行比较那种方式更好同时，也算是复习啦。<br><a id="more"></a>  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2018/05/20/操作系统/study/OS1.jpg" alt="">  </p><hr><p><img src="/2018/05/20/操作系统/study/OS2.jpg" alt="">  </p><hr><p><img src="/2018/05/20/操作系统/study/OS_io.jpg" alt=""> </p><hr><p><img src="/2018/05/20/操作系统/study/OS_file.jpg" alt=""> </p><hr><p><img src="/2018/05/20/操作系统/study/OS_disk.jpg" alt=""> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一次对&lt;strong&gt;面向对象设计与分析&lt;/strong&gt;进行了总结，没有采用&lt;strong&gt;思维导图&lt;/strong&gt;的方式，此次对计算机操作系统的总结采用思维导图的方式，来进行比较那种方式更好同时，也算是复习啦。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://wangyibo.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="操作系统" scheme="http://wangyibo.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA_String类</title>
    <link href="http://wangyibo.top/2018/05/04/JAVA-String%E7%B1%BB/"/>
    <id>http://wangyibo.top/2018/05/04/JAVA-String类/</id>
    <published>2018-05-03T16:44:15.000Z</published>
    <updated>2018-05-03T17:36:34.242Z</updated>
    
    <content type="html"><![CDATA[<p>在程序设计中经常会设计处理和<strong>字符串</strong>有关的算法，而java中提供了专门用来处理字符序列的<strong>String类</strong>。  </p><p>一下就介绍一下java中的String类。 </p><a id="more"></a><p>String类，位于<strong>java.lang</strong>包中。<br>String类被定义为<strong>final类</strong> ，故不可以有子类。  </p><p>1.常量对象<br>    用双引号括起来的字符序列。<br>    String常量也是<strong>对象</strong><br>    如”你好”，”12”<br>    Java把用户程序中的String常量放入<strong>常量池</strong>，常量池中的数据在程序运行期间不能改变。 </p><p>2.String对象<br>    String类声明创建对象。<br>    如：</p><pre><code>String s = new String(&quot;cool&quot;);  String t = new String(&quot;cool&quot;);**注意**  s == t 结果是false。  s 和 t 是不同的引用，尽管实体相同但是会出现上面的情况。  同时用户是无法输出String对象的引用的。system.out.println(s); 输出的是cool。</code></pre><p>3.引用String常量  </p><pre><code>String s1,s2;  s1 = &quot;hi&quot;;  s2 = &quot;hi&quot;;  s1 == s2 返回时true。 实际上时对常量对象的引用，可以这样理解，&quot;hi&quot;本来自己有自己的专属名字，但别人不知道，他也不愿告诉别人，于是就给他起个别名，相当与它的名字，故s1 和 s2都代表它的名字，都指向它之个人。故s1 == s2 是true。</code></pre><p>String类的构造  </p><pre><code>String s = new String(&quot;&quot;);String t = new String(String s);String s = new string(char a[]);String s = new string(char a[], int b, ...);</code></pre><p>字符串的并置：  +</p><p>String类的常用方法：  </p><blockquote><p>public int lenth()<br>public boolean equals(String s)<br>public int compareTo(String s)<br>public boolean startsWith(String s)<br>public boolean endsWith(String s)<br>public boolean contains(String s)<br>public int indexOf(String s)   lastIndexOf(String s)<br>public String substring(int startpoint)<br>public String substring(int start, int end)  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在程序设计中经常会设计处理和&lt;strong&gt;字符串&lt;/strong&gt;有关的算法，而java中提供了专门用来处理字符序列的&lt;strong&gt;String类&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;一下就介绍一下java中的String类。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://wangyibo.top/tags/Java/"/>
    
      <category term="String" scheme="http://wangyibo.top/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>linux进程</title>
    <link href="http://wangyibo.top/2018/05/03/linux%E8%BF%9B%E7%A8%8B/"/>
    <id>http://wangyibo.top/2018/05/03/linux进程/</id>
    <published>2018-05-03T14:11:26.000Z</published>
    <updated>2018-05-03T15:37:22.779Z</updated>
    
    <content type="html"><![CDATA[<p>嗯 在进程这一块的Linux，我总觉得很难，故写个总结，来加深我的理解。<br><strong>Linux下c语言编程实现</strong><br><a id="more"></a></p><p>首先：<br>什么是进程：正在执行的程序。<br>Linux 是多任务操作系统，允许多个用户使用计算机系统，多个进程<strong>并发</strong>执行。<br>Linux 环境下启动进程两种途径： <strong>手动</strong>启动和<strong>调度</strong>启动。  </p><p>一些命令：  </p><blockquote><p>ps  查看系统中的进程<br>top  动态显示系统中的进程<br>nice  按用户指定优先级运行<br>renice  改变正在运行进程的优先级<br>kill  中止进程（包括后台进程）<br>crontab  用于安装，删除或者列出用于驱动cron后台任务<br>bg  将挂起的进程放到后台<br>fg  把后台进程放到前台  </p></blockquote><p>现在了解一下<strong>进程控制</strong>吧：<br>Linux环境下创建进程时，系统会分配一个唯一的数值给每个进程，即<strong>进程标识符</strong>。<br><strong>进程号PID</strong>和<strong>父进程号PPID</strong> &nbsp; 获取PID和PPID的系统调用时 <strong>getpid</strong>和<strong>getppid</strong>函数。  </p><p><strong><em>未完待续</em></strong>  </p><p><br><br>了解一下<strong>进程通信</strong>吧：<br>一些通信方式：</p><pre><code>信号    管道  命名管道  消息队列  共享存储  信号量  套接字  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯 在进程这一块的Linux，我总觉得很难，故写个总结，来加深我的理解。&lt;br&gt;&lt;strong&gt;Linux下c语言编程实现&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://wangyibo.top/tags/linux/"/>
    
      <category term="进程" scheme="http://wangyibo.top/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>OOAD总结</title>
    <link href="http://wangyibo.top/2018/05/02/OOAD%E6%80%BB%E7%BB%93/"/>
    <id>http://wangyibo.top/2018/05/02/OOAD总结/</id>
    <published>2018-05-02T09:09:10.000Z</published>
    <updated>2018-05-05T13:15:14.444Z</updated>
    
    <content type="html"><![CDATA[<hr><p>先简要的了解一下什么是面向对象：把一切都看成是对象。</p><a id="more"></a><h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><p><br><br><br><br><strong>基本思想：运用对象，类，继承，聚合，关联，消息和封装（泛化）等概念和原则来构造软件的开发系统。</strong></p><ol><li>客观世界中的事物<strong>都是对象</strong>，对象之间存在一定关系。  </li><li>用对象的<strong>属性</strong>表示事物的数据特征，对象的<strong>操作</strong>表示事物的行为特征。  </li><li>对象把属性和操作结合在一起，成为不可分的独立实体，对外<strong>屏蔽</strong>具体细节。</li><li>通过<strong>抽象</strong>对事物进行分类，类是致谢对象的抽象描述，每个对象都是类的一个实例  </li><li>复杂的对象可以用简单的对象作为<strong>构成</strong>部分。</li><li>特殊类<strong>继承</strong>一般类的属性。</li><li>对象之间通过<strong>消息</strong>将进行通信，以实现对象之间的动态的联系。</li><li>通过<strong>关联</strong>表达类之间的静态关系。  </li></ol><p><br><br><br><br><strong>基本原则：抽象，分类，封装，消息通信，多态性，行为分析和复杂性控制</strong></p><ol><li><strong>抽象：</strong>从事物中舍弃个别的，非本质的特征，而抽取共同的，本质特征的思维方式。<ol><li>过程抽象：形成操作；数据抽象：把数据类型和施加在其上的操作结合在一起形成一种新的数据类型。（类和栈就是数据抽象）。  </li><li>对象是对现实世界中事物的抽象，类是对对象的抽象，一般类是对特殊类的抽象。    </li><li>面向对象的不同开发阶段需要进行不同的抽象。<br><br></li></ol></li><li><strong>分类：</strong>按照某种原则划分事物的区别，有助于认识复杂的世界。<br><br></li><li><strong>封装：</strong><ol><li>把描述一个事物的性质和行为结合在一起，对外形成该事物的一个界限。</li><li>信息屏蔽，外界不能直接存取对象的内部信息（属性），隐藏内部操作，外界也不用知道对外操作的具体细节。<br><br></li></ol></li><li><strong>消息通信：</strong>对象之间只能通过消息进行通信。又封装原则引起。<br><br></li><li><strong>多态性：</strong>一般类和特殊类可以有相同格式的属性和操作，但这些属性和操作具有不同的含义，即不同的数据类型或表现不同的行为。函数重载；运算符重载。<br><br></li><li><strong>行为分析：</strong>通过状态图，交互图进行对象行为分析。<br><br></li><li><strong>复杂性控制：</strong>引入了包的概念。</li></ol><p><br><br><br><br><strong>主要优点：</strong></p><ol><li>从认识论的角度，改变了开发软件的<strong>方式</strong>。</li><li>使得从<strong>客观世界</strong>到<strong>计算机的语言</strong>鸿沟变窄。</li><li>使得<strong>分析</strong>与<strong>设计</strong>之间的鸿沟变窄。</li><li>有助于软件的<strong>维护与复用</strong>。提高了对象的内聚性，减少了与其他对象的耦合。</li><li>有助于提高软件<strong>质量和生产率</strong>。</li></ol><p><br><br><br><br><strong>统一建模语言UML：</strong><br>只是一种建模语言，而不是建模方法；<br>UML独立于开发过程，可以适用于不同的开发过程。<br>UML2.4规范由四个部分组成：</p><ol><li><strong>基础结构</strong>：定义建模语言的核心构造物</li><li><strong>上层结构</strong>：定义建模语言——UML</li><li><strong>对象约束语言</strong>：精确的方式描述基础结构，上层结构及用户建立模型中的表达式和约束    </li><li><strong>图交换</strong>：规定了如何定义用于数据交换的XML文件的格式<br>UML2.4支持的模型图在逻辑上分为：<strong>结构图</strong>（静态方面）和<strong>行为图</strong>（动态方面）  </li></ol><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><hr><h2 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h2><p>运用面向对象的方法进行系统分析。<br><br><br><br><br><strong>面临的主要问题：</strong></p><ol><li>问题域和系统责任：<ol><li><strong>问题域：</strong>被开发系统的应用领域，即在现实世界中这个系统所涉及的业务范围。</li><li><strong>系统责任：</strong> 被开发系统应具有的职能。</li></ol></li><li>交流问题</li><li>需求的不断变化</li><li>软件复用的要求<br><br><br><br></li></ol><p><strong>综述</strong></p><p>系统分析：研究问题域，产生一个满足用户需求的系统分析模型。<br>面向对象的软件建模规范——概念与表示法</p><ol><li><strong>概念与表示法</strong><br><br></li><li><strong>OOA模型：</strong>面向对象分析所建立的系统模型，表达了OOA阶段所认识到的系统成分及彼此间的关系。<ol><li>需求模型：用况图</li><li>基本模型： 类图<ol><li>对象层：给出系统中所有反映问题域与系统责任的对象。<strong>类是构成系统的基本单位</strong>。</li><li>特征层：给出每一个类的<strong>内部特征</strong>，给出你每个类的属性和操作。</li><li>关系层：给出各个类之间的<strong>关系</strong>。</li></ol></li><li>辅助模型： 顺序图，活动图，状态图，包图。</li><li>模型规约：文档，进行详说明。  </li></ol></li></ol><p>可以建立对象图，作为类图的补充。</p><p><br></p><h2 id="—-1"><a href="#—-1" class="headerlink" title="—-"></a>—-</h2><hr><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="用况图"><a href="#用况图" class="headerlink" title="用况图"></a>用况图</h3><p> <strong>系统边界：</strong>系统边界是一个系统所包含的所有系统成分与系统以外的事物的分界线。<br> <strong>参与者：</strong>一组在功能上密切相关的角色，当一个事物与系统交互时，该事物要扮演这样的角色。 <strong>参与者不是系统的一部分，他们位于系统之外，是在系统之外的与系统交互的任何事物。</strong></p><p><em>识别参与者</em>:</p><ol><li><strong>人员</strong>：直接使用系统的人员中发现参与者。</li><li><strong>外部系统</strong>：所有与本系统交互的外部系统都是参与者。</li><li><strong>设备</strong>：与系统相连，像系统提供外界信息；也可能系统向设备提供信息，设备在系统的控制下运行（不包括监视器，键盘，鼠标这样的标准用户接口设别）。<br><strong>用况：</strong>一个用况是描述系统的一项功能的一组动作序列，这样的动作序列表示参与者与系统的交互，系统执行该动作序列<strong>要为参与者产生结果</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意：</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 用况是一种<strong>类型</strong>，它是要被<strong>实例化执行</strong>的。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 用况描述中的一个动作应该<strong>描述参与者</strong>或<strong>系统要完成的一个交互步骤</strong>。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 执行用况的一个动作序列要为参与者<strong>产生可观察的结果</strong>。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 保证用况所对应的<strong>功能完整</strong>，用况不分层，不能说上层的用况是由下层较小的用况组成。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 用况<strong>不说明</strong>具体<strong>细节</strong>。  </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>关系：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与参与者之间：<strong>关联</strong> 是参与者与用况的唯一关系。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用况间的关系：<strong>包含</strong>， <strong>扩展</strong>，<strong>继承</strong>。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>捕获用况：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 从<strong>参与者</strong>的角度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 从<strong>系统功能</strong>的角度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 利用<strong>场景</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>用况模板</strong>  </p><p> <strong>用况图</strong>  </p><p>  定义： 是由<strong>参与者</strong>，<strong>用况</strong>以及这些元素之间的的<strong>关系</strong>组成的图。<br>  检查与调整：<br>  每个<strong>参与者至少与一个用况相关联</strong>。<br>  参与者之间可以有<strong>继承</strong>关系<br>  不能按照人机界面建立用况，<strong>界面不是用况，用况也不是界面</strong>。  </p><hr><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p> 类图描述了系统中各类对象以及他们之间的各种关系。  </p><h4 id="概念与表示法"><a href="#概念与表示法" class="headerlink" title="概念与表示法"></a>概念与表示法</h4><p> <strong>对象：</strong> 是具有明确的语义边界并封装了状态和行为的实体，由一组属性和作用在这组属性上的一组操作构成，他是构成软件系统的<strong>基本单位</strong>。<br> <strong>类：</strong>是具有<strong>相同属性</strong>和<strong>操作</strong>的一组对象的统一抽象描述，对象是类的实例。  </p><p> <strong>对象的审查和筛选</strong></p><ul><li>舍弃无用对象：1.通过<strong>属性</strong>判断；2.通过<strong>操作</strong>判断。  </li><li>精简对象：只有<strong>一个</strong>属性或操作的对象。 </li><li>推迟到<strong>OOD</strong>考虑的对象。<br><strong>抽象出类并进行调整</strong><br><strong>主动对象及主动行为：</strong></li><li>主动对象：具有<strong>主动行为</strong>的对象，在设计阶段是拥有线程或进程并启动<strong>控制活动</strong>的对象  。</li><li><p>主动类：是其实例为主动对象的类。    </p><p><strong>建立类的对象层</strong> </p></li></ul><h4 id="属性和操作"><a href="#属性和操作" class="headerlink" title="属性和操作"></a>属性和操作</h4><ol><li>属性： 描述对象性质的<strong>数据项</strong>。   （实例属性， 类属性）<br>格式： [可见性] 属性名[：类型] [=初始值]    </li><li>操作： 类的对象被要求提供的<strong>服务的规约</strong>。<br>格式：[可见性] 操作名 [ (参数列表) ] [：返回类型] （实例操作，类操作）<br>系统行为， 对象行为（算法简单，算法复杂）。  <blockquote><p>对象的审查：是否有用，是否高内聚。 </p></blockquote></li></ol><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><ol><li><strong>继承:</strong>   <ul><li>类A的全部对象都是类B的对象，且类B中存在不属于类A的对象，则A是B的特殊类，B是A的一般类，A与B之间的关系叫继承。</li><li>类A具有类B的特征，且还具有自己的一些特征，则A叫做B的特殊类，B是A的一般类，A与B之间的关系叫继承。  </li></ul></li></ol><blockquote><p>非对称性<br>传递性</p><p>多继承<br>单继承  </p><p>表示法  </p></blockquote><ol><li><strong>关联</strong><br>关联是一个或一组类的对象集合的笛卡尔积上的一个子集合（即一个由对象构成的集合），这种类间的关系用于刻画同种或异种类别事物间的关系。<br><strong>一元关联</strong>：连接到自身的关联。<br><strong>链</strong>：关联的一个实例（即一个对象偶对），用于刻画具体事物间的关系。 若在两个对象间建立了链，一个对象就可以直接访问另一个对象。在对象生命周期内，对象之间的链是在某段时间内存在的。<br><strong>多重性</strong><br><strong>关联角色</strong><br><strong>关联类</strong>：关联类是兼有关联和类的双重特征的建模元素，既可以把关联类看作是具有类的关联特征的关联，也可以看作是具有关联特征的类。<br>因其超过了当前面向对象编程语言的概念范围，可以通过<strong>增设类</strong>把关联类表示为普通类。<br><strong>N元关联</strong>：三个或三个以上的关联。<br><strong>限定符</strong>  </li></ol><ol><li><p><strong>聚合</strong><br>客观世界中，事物之间的整体-部分关系是大量存在的。运用聚合可清晰的表达事物之间的整体-部分关系。减少认识事物的复杂性。<br>可以理解为：一个类的定义引用了<strong>另一个类</strong>定义。<br>作为<strong>整体</strong>的类称为 聚集 ；作为<strong>部分</strong>的类称为 成分  </p><blockquote><p>非对称性<br>传递性</p></blockquote><p><strong>组合</strong>是聚合的一种形式，一个部分类的对象在一个时刻必须最多属于一个整体类的对象，且整体类的对象管理它的部分类的对象。<br>聚合表示成一条一端带有一个菱形的线段，组合菱形是实心的。  </p></li></ol><ol><li><p><strong>依赖</strong><br>表明一个元素（源元素）的定义或实现<strong>依赖</strong>另一个元素的定义或实现，即对被依赖的元素的改变要改变该关系中的源元素，其中的元素可以是单个的模型元素，也可以是集合类型的模型元素。<br>在用况图中的包含（include） 扩展（extend） 就是依赖。<br>把依赖表示为两个建模元素之间的虚线。箭头尾部元素依赖箭头头部元素    </p></li><li><p><strong>接口</strong><br>接口声明了一组操作，用以刻画模型元素对外提供的服务或者它所需要的外部服务。这样的元素可以是类，以刻是构件和子系统。<br>一个类可实现一个或多个接口，把这样的接口称为类的<strong>供接口</strong>，一个或多个类可使用一个或多个接口，把这样的接口称为<strong>需接口</strong>。  </p></li></ol><h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p>顺序图是一种详细描述<strong>对象之间</strong>以及<strong>对象</strong>与<strong>参与者</strong>之间交互的图，它由一组相互协作的对象或参与者实例以及它们之间的消息组成，强调<strong>消息之间的顺序</strong>。<br>组成：<br>对象生命线：表示对象在一段时间内的存在。<br>执行规约：是一个对象执行一个操作的时期。在执行该操作时可能还调用了本对象或者其他对象中的操作。<br>消息：是对象之间的通信规格说明，这样的通信用于传输将发生的活动所需要的信息，既包含了控制（如调用）的规格说明，也包含了使用的数据之间的规格说明。<br>&nbsp;&nbsp;同步消息：一般用于普通的过程调用。<br>&nbsp;&nbsp;异步消息：用于表示异步通信，即发送者发出信号后，立即执行下一步操作，不进行等待。<br>信号： 是对象之间的异步通信的规格说明。  信号名 （参数名：类型表达式，参数名：类型表达式）  </p><p>顺序图中的结构化控制：<br>sd 标签<br>可选执行 opt<br>条件执行 alt<br>并行执行 par<br>循环执行 loop<br>引用 ref </p><h3 id="通信图"><a href="#通信图" class="headerlink" title="通信图"></a>通信图</h3><p>强调发送和接受消息的对象组织结构的图，用以展示围绕对象以及他们之间的的连接器而组织的交互。  </p><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><p>描述动作，动作的执行次序以及动作的输入与输出的图，由动作节点和边构成。  </p><p>动作：可执行的基本功能单元，描述状态转换或活动，是原子的和即时的。<br>活动：有一组相互协作的动作构成的行为单元。活动在执行中可以被事件中断。<br>控制流；当动作结束时，马上进入下一个的动作流程。可以并发。<br>对象流：在控制流中可含有对象，用以描述动作间输入与输出的数据。<br>泳道：在对业务过程建模时，可以把动作分成组，每组由特定的履行者来执行。每个组分别称为一个泳道。  </p><h3 id="状态机图"><a href="#状态机图" class="headerlink" title="状态机图"></a>状态机图</h3><p>描述了一个对象在其生命周期内因响应事件所经历的状态序列以及对这些事件做出的反应。<br>状态机图主要由状态和状态间的转移构成的。  </p><p>事件：信号事件，调用事件，时间事件，改变事件。  事件名（参数名：类型表达式，参数名：类型表达式）<br>状态：对象在其生命周期中满足特定的条件，进行特定的活动或等待特定时间的状况。  初始状态，终止状态都是<strong>伪状态</strong>。<br>转移：状态间的转移，状态内的转移。  事件触发器[(参数名：类型表达式…)] [监护条件] / [动作表达式]<br>&nbsp;&nbsp;状态内的转移：entry/进入动作表达式；exit/退出动作表达式；do/活动<br>&nbsp;&nbsp;状态间的转移：<br>正交状态：具有多个区域的组合状态； 非正交状态：只有一个区域的组合状态。  </p><h3 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h3><p>描述模型元素分组以及分组之间依赖的图，其中要用到的包时对模型元素进行分组的机制。  ::<br>一个包形成了一个命名空间。一个包的语境中同一种元素的名字必须唯一，在一个包中不同种类的模型元素可以有相同的名字。  </p><p>包间的关系：<br>拥有<br>引入依赖 箭头指向提供者包。 &lt;&lt; import &gt;&gt;  相当于把提供者包的内容附加到客户包的<strong>公共命名空间中</strong><br>访问依赖 箭头指向提供者包。 &lt;&lt; access &gt;&gt;  相当于把提供者包的内容附加到客户包的<strong>私有命名空间中</strong><br>继承   </p><h2 id="—-2"><a href="#—-2" class="headerlink" title="—-"></a>—-</h2><hr><h2 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h2><p>OOD模型：<br>核心部分：问题域部分（OOA的结果作为输出）<br>外围部分：人机交互部分，控制驱动部分，数据管理部分，构建及部署部分（最后进行）。  </p><h3 id="问题域部分的设计："><a href="#问题域部分的设计：" class="headerlink" title="问题域部分的设计："></a>问题域部分的设计：</h3><p>复用类  {复用} 标记<br>增加一般类以建立公共协议<br>提高性能  </p><p><strong>按编程语言调整继承</strong><br>多继承的调整：1.采用聚合把多继承换位单继承；2.采用压平的方式<br>取消继承<br>对多态性的调整  </p><p><strong>转化复杂关联并决定关联的实现方式</strong><br>转化复杂关联：1.把关联类和N元关联转化为二元关联；2.把多对多关联转化为一对多关联。<br>决定关联的实现方式：1.聚合；2关联  c++指针变量， java引用变量  </p><p><strong>调整与完善属性</strong><br>语法： [可见性] 属性名[‘:’类型] [‘=’ 初始值]<br>对需要明确但在OOA还没有确定可见性的属性进行标记。按照OO的信息隐蔽原则，要尽可能地保持数据私有化。  </p><p><strong>构造及优化算法</strong><br>操作：[可见性] 操作名[(参数列表)] [: 返回类型]<br>完善操作的定义，设计算法，异常处理。  </p><p><strong>决定对象间的可访问性</strong><br>类A的对象和类B的对象之间存在者链<br>类B的对象变量作为类A的一个操作参数<br>类B的对象变量在类A的一个操作方法中被声明为局部的<br>类B的对象时全局可见的  </p><p><strong>定义对象实例</strong>  </p><h3 id="人机交互部分的设计："><a href="#人机交互部分的设计：" class="headerlink" title="人机交互部分的设计："></a>人机交互部分的设计：</h3><p>突出人如何命令系统以及系统如何向用户提交信息。<br>从<strong>用况</strong>分析人机交互<br>设计输入，设计输出<br><strong>命令的组织</strong>：设计用户使用系统的命令以及对命令的组织<br>&nbsp;&nbsp;1.分解；2.组合（形成层次结构）<br>&nbsp;&nbsp;基本命令：使用一项独立的系统功能命令；<br>&nbsp;&nbsp;命令步：执行一条基本命令的交互过程中所包含的具体输入步骤。<br>&nbsp;&nbsp;高层命令：如果一条命令实在另一条命令的引导下被选用的，则后者称作前者的高层命令。<br>&nbsp;&nbsp;命令步直接按可能存在三种输出信息结构：1.反馈信息（如进度条）；2.处理结果（当前命令的执行结果）；3.提示信息<br>&nbsp;&nbsp;建立命令树时策略：1.用最频繁的命令放在方便处；2.在命令中发现整体-部分模式；3.7+-2原则，命令层次深度尽量小。<br><strong>用OO概念表达所有的界面成分</strong><br><strong>衔接界面模型和问题域模型</strong><br><strong>人机交互部分的设计准则</strong><br>&nbsp;&nbsp;1.易学，易用。操作方便<br>&nbsp;&nbsp;2.尽量保持一致<br>&nbsp;&nbsp;3.及时提供有意义的反馈<br>&nbsp;&nbsp;4.使用户的注意力集中在当前的任务上而不是界面上<br>&nbsp;&nbsp;5.减少用户记忆<br>&nbsp;&nbsp;6.具有语境敏感帮助功能<br>&nbsp;&nbsp;7.减少重复的输入和操作<br>&nbsp;&nbsp;8.防止灾难性的错误<br>&nbsp;&nbsp;9.其他  </p><h3 id="控制驱动部分的设计"><a href="#控制驱动部分的设计" class="headerlink" title="控制驱动部分的设计"></a>控制驱动部分的设计</h3><p>这部分由系统中<strong>全部的主动类</strong>构成<br>每个主动类所创建的一个主动对象是系统中一个控制流的驱动者<br><strong>控制流</strong>：进程和线程的统称<br>&nbsp;&nbsp;进程时处理机的分配单位，也是存储空间，设备等资源的分配单位；线程只是处理机的分配单位。<br>&nbsp;&nbsp;控制流的创建：当创建了一个主动对象时<br>&nbsp;&nbsp;控制流的撤销：当撤销主动对象时<br><strong>设置控制驱动部分</strong>  控制流的表示：&lt;&lt; progress &gt;&gt; 或 &lt;&lt; thread &gt;&gt;<br><strong>进程和线程间的通信</strong>1.操作调用；2.邮箱；3.共享存储器；4.远程过程调用；（1.2.3：线程）（2.3.4：进程）<br>&nbsp;&nbsp;控制流间的同步：为了<strong>协调</strong>并发控制流的执行，以<strong>防止</strong>多控制流同时读写共享资源以及防止控制流的<strong>死锁</strong>和控制流的<strong>饿死</strong><br>&nbsp;&nbsp;实现：把所操作的对象作为临界资源，然后加以同步。 1.顺序的（sequential） 2.受监护的（guarded） 3.并发的（concurrent）<br>&nbsp;&nbsp;进一步地，对于多个需要相互交互的控制流，可以考虑使用哦个一个或几个控制流，起协调者的作用  </p><h3 id="数据管理部分的设计"><a href="#数据管理部分的设计" class="headerlink" title="数据管理部分的设计"></a>数据管理部分的设计</h3><p>需要长期存储的对象，称为<strong>持久对象</strong>，其属于的类属于<strong>持久类</strong><br>数据管理部分负责<strong>存储和检索持久对象</strong>，<strong>封装</strong>对这些对象的<strong>查找和存储机制</strong>，以隔离数据管理方案对其他部分的影响，特别是对<strong>问题域</strong>部分的影响   </p><p>数据库：是<strong>长期</strong>存在于计算机内，有组织，可共享的数据<strong>集合</strong><br>数据库管理系统：用于建立，使用和维护数据库的<strong>软件</strong>，它对数据库进行统一的管理和控制，以保证数据库的<strong>完整性和安全性</strong><br>&nbsp;&nbsp;关系数据库<br>&nbsp;&nbsp;面向对象数据库  </p><h3 id="构件及部署部分的设计"><a href="#构件及部署部分的设计" class="headerlink" title="构件及部署部分的设计"></a>构件及部署部分的设计</h3><p><strong>构建设计</strong> 构建图是描述<strong>构件</strong>，<strong>构件的内部结构</strong>和<strong>构建之间</strong>关系的图<br>&nbsp;&nbsp;构件：是系统中可<strong>替换和复用</strong>的模块化部分，它<strong>封装</strong>了自己的内容，利用<strong>供接口和需接口</strong>定义自身的行为；起类型的作用. 构件内部的一个部件：另一个构件，端口，类<br>&nbsp;&nbsp;&nbsp;&nbsp;表示：带有&lt;<component>&gt;的矩形，右上角可放一个图标<br>&nbsp;&nbsp;构件的接口：<br>&nbsp;&nbsp;&nbsp;&nbsp;构件的供接口：构件实现的接口； 构件的需接口：构建需要使用的接口，即构件向其他构件请求服务时要遵循的接口；<br>&nbsp;&nbsp;&nbsp;&nbsp;一个构件可以实现多个接口，也可以请求多个接口。一个接口可以由多个不同构件实现<br>&nbsp;&nbsp;&nbsp;&nbsp;三种表示：1.简略的图符形式；2.扩展方式；3.分栏矩形<br>&nbsp;&nbsp;构建的端口：描述了在构件与它的环境之间以及在构件与它的内部部件之间的一个显示的交互点，即端口时一个封装构件的显示的对外窗口，所有进出构件的消息都要进过端口。<br>&nbsp;&nbsp;&nbsp;&nbsp;表示：一个挎在构件边上的小方块<br>&nbsp;&nbsp;连接件：装配连接件；委托连接件<br>&nbsp;&nbsp;构件的内部结构：可以在构件的矩形图符上加一个分栏中来列出其内部组成元素（如接口，部件，连接件）：&lt;<realization>&gt;构件内部成分，&lt;<artifact>&gt;物理实现体<br>&nbsp;&nbsp;对构件的行为建模<br>&nbsp;&nbsp;对构件的实现建模  制品：工作产业制品（源代码等），部署制品（exe文件等）。&nbsp;&nbsp;类型级，实例级  &lt;&lt; manifest &gt;&gt;承载（一种依赖关系）<br>&nbsp;&nbsp;部署设计 <strong>节点</strong>是<strong>制品</strong>可部署并执行在其上的<strong>计算资源</strong>，并能够通过通信路径互联.通常把节点看成是一个可以在其上部署可执行制品的运行环境  表示：立方体<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; deploy &gt;&gt;</artifact></realization></component></p><h2 id="—-3"><a href="#—-3" class="headerlink" title="—-"></a>—-</h2><hr><h2 id="若干设计模式"><a href="#若干设计模式" class="headerlink" title="若干设计模式"></a>若干设计模式</h2><p>设计模式分类：<br>1.结构型：通过用<strong>接口</strong>将实现与抽象联系起来的方式把已由对象<strong>组合</strong>起来进行建模<br>2.行为型：通过对变化进行<strong>封装</strong>使得所建立的模型可以提供<strong>灵活</strong>的方式<br>3.创建型：用于对<strong>创建对象</strong>的建模  </p><p>原则：<br>1.针对接口编程<br>2.优先使用组合，而不是继承<br>3.正确的使用委托<br>4.找出变化并进行封装  </p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>用于为子系统中的一组对象提供统一的接口，使得系统更易于使用。也可以说,通过<strong>量身定做</strong>来建立提供所需功能的接口  </p><div class="table-container"><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center">外观模式</td></tr><tr><td style="text-align:center">意图</td><td style="text-align:center">通过定义所需要的接口，简化原有系统的使用方式</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:center">只使用原系统的功能部分，或以特殊方式于系统交互</td></tr><tr><td style="text-align:center">解决方案</td><td style="text-align:center">为原有系统的用户提供新的接口</td></tr><tr><td style="text-align:center">协作者</td><td style="text-align:center">系统，接口，用户</td></tr><tr><td style="text-align:center">效果</td><td style="text-align:center">简化了所需子系统的使用方法</td></tr></tbody></table></div><p><img src="/2018/05/02/OOAD总结/study/waiguanmoshi.jpg" alt="">  </p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>用于将类的一个接口<strong>转化</strong>为另一个类所需的接口，以使由于<strong>接口不兼容</strong>的类能够一起协作  </p><div class="table-container"><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center">适配器模式</td></tr><tr><td style="text-align:center">意图</td><td style="text-align:center">使一个类的接口与一个结构（通常使用多态机制的继承结构）中的类的接口相匹配</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:center">一个类的操作的语义与一个结构中的类的接口相一致，但特征标记有差异</td></tr><tr><td style="text-align:center">解决方案</td><td style="text-align:center">该模式提供了起包装作用的类，以使得接口相一致</td></tr><tr><td style="text-align:center">协作者</td><td style="text-align:center">适配者，被适配者，一般类，客户</td></tr><tr><td style="text-align:center">效果</td><td style="text-align:center">使得原有类与所需结构的接口相匹配</td></tr></tbody></table></div><p><img src="/2018/05/02/OOAD总结/study/shipeiqimoshi.jpg" alt="">  </p><center>外观模式与适配器模式的比较</center><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">外观模式</th><th style="text-align:center">适配器模式</th></tr></thead><tbody><tr><td style="text-align:center">按特定接口设计</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">使用多态机制</td><td style="text-align:center">否</td><td style="text-align:center">可能</td></tr><tr><td style="text-align:center">目标接口更简单</td><td style="text-align:center">是</td><td style="text-align:center">没变化</td></tr></tbody></table></div><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>描述怎样按需要在一组<strong>可替换的算法</strong>中选用算法，即把所定义的一些算法各自<strong>封装</strong>起来，可根据<strong>客户的需要</strong>分别使用他们。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center">策略模式</td></tr><tr><td style="text-align:center">意图</td><td style="text-align:center">根据语境使用不同的业务规则或算法</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:center">处理客户数据的算法种类可能发生变化，且要根据需要选择算法</td></tr><tr><td style="text-align:center">解决方案</td><td style="text-align:center">把对算法的选择和算法的实现相分离，并根据语境选择算法</td></tr><tr><td style="text-align:center">协作者</td><td style="text-align:center">语境，抽象策略，具体策略</td></tr><tr><td style="text-align:center">效果</td><td style="text-align:center">按需要定义算法，并可按相同的方式使用：封装了算法种类的变化性</td></tr></tbody></table></div><p><img src="/2018/05/02/OOAD总结/study/celuemoshi.jpg" alt="">  </p><h3 id="观察者模式（发布-订阅模式）"><a href="#观察者模式（发布-订阅模式）" class="headerlink" title="观察者模式（发布-订阅模式）"></a>观察者模式（发布-订阅模式）</h3><p>用于定义对象间的<strong>一对多的依赖关系</strong>，当一个对象发生变化并对外发布消息时，所有依赖它的对象都将<strong>得到通知并可进行更新</strong>  </p><div class="table-container"><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center">观察者模式</td></tr><tr><td style="text-align:center">意图</td><td style="text-align:center">用于定义对象间的一对多的依赖关系，当一个对象发生变化并对外发布消息时，所有依赖它的对象都将得到通知并可进行更新</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:center">当一个对象发生变化并对外发布消息时，需要向对象数目不定的对象集发出通知</td></tr><tr><td style="text-align:center">解决方案</td><td style="text-align:center">观察者将检测事件的责任委托给一个专门的对象</td></tr><tr><td style="text-align:center">协作者</td><td style="text-align:center">事件发布者，具体事件发布者，观察者，具体观察者</td></tr><tr><td style="text-align:center">效果</td><td style="text-align:center">如果某些观察者只对一部分事件感兴趣，那么它们可只订阅这些事件。发布者和观察者均可独立变化，只是二者中已规定的操作除外</td></tr></tbody></table></div><p><img src="/2018/05/02/OOAD总结/study/guanchazhemoshi.png" alt="">  </p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>在<strong>一般类</strong>中定义一个用于创建对象的<strong>接口</strong>，让<strong>特殊类</strong>的对象决定实例化哪一个类。该模式把创建对象的工作推给特殊类的对象  </p><div class="table-container"><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center">工厂方法模式</td></tr><tr><td style="text-align:center">意图</td><td style="text-align:center">定义一个用于创建对象的接口的接口，让特殊类的对象创建对象，即把创建对象的工作推迟给特殊类的对象去完成</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:center">需要创建不同种类的对象，但不知道创建哪一种，而让特殊类去决策</td></tr><tr><td style="text-align:center">解决方案</td><td style="text-align:center">特殊类的对象负责创建对象</td></tr><tr><td style="text-align:center">协作者</td><td style="text-align:center">抽象产品，具体产品，抽象创建者，具体创建者</td></tr><tr><td style="text-align:center">效果</td><td style="text-align:center">通过创建的特殊类，客户可得到所需要的对象</td></tr></tbody></table></div><p><img src="/2018/05/02/OOAD总结/study/gongchangfangfa.jpg" alt="">  </p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>为创建一组<strong>相关或相互依赖</strong>的对象提供一个<strong>接口</strong>，而<strong>不需要</strong>指出用于创建对象的<strong>具体类</strong>。  </p><div class="table-container"><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center">抽象工厂模式</td></tr><tr><td style="text-align:center">意图</td><td style="text-align:center">为特定的客户端提供一组对象</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:center">需要实例化出一组相关对象</td></tr><tr><td style="text-align:center">解决方案</td><td style="text-align:center">提供一种方式，把创建对象的规则从使用这些对象的客户对象中提取出来，放在负责创建对象组的工厂中</td></tr><tr><td style="text-align:center">协作者</td><td style="text-align:center">客户，抽象产品，具体产品，抽象工厂，具体工厂</td></tr><tr><td style="text-align:center">效果</td><td style="text-align:center">把使用哪些对象与创建者些对象的逻辑分开</td></tr></tbody></table></div><p><img src="/2018/05/02/OOAD总结/study/chouxianggongchang.jpg" alt="">  </p><h2 id="—-4"><a href="#—-4" class="headerlink" title="—-"></a>—-</h2><hr><h2 id="OOD的评价准则"><a href="#OOD的评价准则" class="headerlink" title="OOD的评价准则"></a>OOD的评价准则</h2><p>耦合：描述OOD成分之间的联系的紧密程度。  考虑耦合的目的：改动一部分，对其他部分的影响应尽量地小；阅读一部分，需要查阅的其他部分也要尽量少<br>&nbsp;&nbsp;交互耦合：模型成分间通过消息的交互程度  <strong>弱</strong>耦合好<br>&nbsp;&nbsp;继承耦合：特殊类继承一般类的属性和操作的数量程度  <strong>强</strong>耦合好<br>内聚：描述一个OOD成分内所完成功能的紧密程度<br>&nbsp;&nbsp;操作内聚：若一个操作只完成一项功能，则说它是高内聚的<br>&nbsp;&nbsp;类内聚：一个类内的属性和操作应该描述类本身的责任，属性均与操作相关，而且其内的所有操作作为一个整体也是紧密相关的<br>&nbsp;&nbsp;继承内聚：继承关系要讲的通<br>复用：复用以有的软件制品，能节省软件的开发成本，提高软件的质量和生产率<br>其他评价准则：<br>&nbsp;&nbsp;清晰度好<br>&nbsp;&nbsp;继承层次深度适当<br>&nbsp;&nbsp;保持对象和类的简单性<br>&nbsp;&nbsp;所有需要的属性和操作都要被适当地的使用<br>&nbsp;&nbsp;尽量地使用与提炼设计模式<br>&nbsp;&nbsp;考虑设计易变性地最小化  </p><h2 id="—-5"><a href="#—-5" class="headerlink" title="—-"></a>—-</h2><hr><h2 id="系统与模型"><a href="#系统与模型" class="headerlink" title="系统与模型"></a>系统与模型</h2><p>系统：是由为了达到特定目的而组织起来的模型元素构成的，可用从不同抽象层次和不同角度建造的模型来描述它。<br>如果一个系统较为复杂，可把它分解成一组子系统。每个子系统要完成特定的功能，有自己的应用环境，通过接口与系统交互<br>&lt;&lt; system &gt;&gt; 系统  &lt;&lt; subsystem &gt;&gt;子系统<br>对体系结构建模：<br>1.三层体系结构模式：用户界面，业务逻辑，数据管理<br>2.管道过滤型体系结构模式<br>模型：为了更好的描述事物的抽象<br>视图：是系统模型在某一侧面的投影，即它是观察或突出所被建模的系统的一个侧面（视角），其中要忽略与这以侧面无关的方面<br>五个视图，两个方面：用况视图，实现视图，进程视图，设计视图，部署视图， 静态方面，动态方面<br>&lt;&lt; trace &gt;&gt;的虚线 追踪依赖  从低层模型中的元素指向相邻高层模型中的元素<br>用带有一个三角图符或&lt;&lt; model &gt;&gt;的包图表示模型    </p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;先简要的了解一下什么是面向对象：把一切都看成是对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面向对象" scheme="http://wangyibo.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="UML" scheme="http://wangyibo.top/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>你</title>
    <link href="http://wangyibo.top/2018/04/29/%E4%BD%A0/"/>
    <id>http://wangyibo.top/2018/04/29/你/</id>
    <published>2018-04-29T15:11:32.000Z</published>
    <updated>2018-04-30T03:24:17.557Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/04/29/你/img/me.jpg" alt=""></p><h3 id="博客终于建好了"><a href="#博客终于建好了" class="headerlink" title="博客终于建好了"></a>博客终于建好了</h3><h3 id="非常开心，你是我的博客的第一个浏览者"><a href="#非常开心，你是我的博客的第一个浏览者" class="headerlink" title="非常开心，你是我的博客的第一个浏览者"></a>非常开心，你是我的博客的第一个浏览者</h3><p>当然，作为第一个浏览者，我也要给你写些东西吧，开业大酬宾。<br>我想了好久，不知道写啥。<br>不过在我的不懈努力下，还是想到了。<br>嘻嘻(●’◡’●)</p><a id="more"></a><h2 id="乐华"><a href="#乐华" class="headerlink" title="乐华"></a>乐华</h2><p><img src="/2018/04/29/你/blogimg/lh1.jpg" alt=""><br><br><br><img src="/2018/04/29/你/blogimg/lh2.jpg" alt=""><br><br><br><br><br>我记得那天我们去了好多地方。<br>在大唐芙蓉园，散了步，看见了好多拍婚纱照的人。<br>在海洋馆，看了好多小动物，当然我觉得海洋馆最多的还是小孩纸。<br>在乐华，玩了好多过山车，看了5D电影，不过你没玩跳楼机哦。<br><br></p><h2 id="做蛋糕"><a href="#做蛋糕" class="headerlink" title="做蛋糕"></a>做蛋糕</h2><p><img src="/2018/04/29/你/blogimg/zdg2.jpg" alt=""><br><br></p><p><img src="/2018/04/29/你/blogimg/zdg.jpg" alt=""><br><br><br>这是元旦。<br>一大早，去看电影，结果进不去，就在底下各种找进去的路。<br>下午去做蛋糕喽，咱么的蛋糕好可爱。<br><br></p><h2 id="西安电视塔"><a href="#西安电视塔" class="headerlink" title="西安电视塔"></a>西安电视塔</h2><p><img src="/2018/04/29/你/blogimg/tv.jpg" alt=""><br><br></p><p><img src="/2018/04/29/你/blogimg/tv2.jpg" alt=""><br><br><br>在西安电视塔的最高处，站在玻璃上。<br>我一想到你在上面不敢走动，就想笑，你真是太可爱啦。<br>在科技馆，走那个玻璃迷宫，你不停的撞。<br>夜里买了书，吃了泡馍。<br><br></p><h2 id="樱花"><a href="#樱花" class="headerlink" title="樱花"></a>樱花</h2><p><img src="/2018/04/29/你/blogimg/yh.jpg" alt=""><br><br></p><p><img src="/2018/04/29/你/blogimg/yh2.jpg" alt=""><br><br><br>樱花开了，赏花去喽。</p><p><strong>嗯 放张合照吧</strong><br><img src="/2018/04/29/你/blogimg/hez.jpg" alt=""><br><br></p><h2 id="全都是你啦"><a href="#全都是你啦" class="headerlink" title="全都是你啦"></a>全都是你啦</h2><p><img src="/2018/04/29/你/blogimg/yz.jpg" alt=""><br><img src="/2018/04/29/你/blogimg/yz1.jpg" alt=""><br><img src="/2018/04/29/你/blogimg/yz2.jpg" alt=""><br><img src="/2018/04/29/你/blogimg/yz3.jpg" alt=""></p><p><br></p><h2 id="嗯-是不是该抒情了"><a href="#嗯-是不是该抒情了" class="headerlink" title="嗯 是不是该抒情了"></a>嗯 是不是该抒情了</h2><p><strong>我喜欢的样子，你都有</strong></p><p align="right"> ---《甜甜的》周杰伦</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/04/29/你/img/me.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;博客终于建好了&quot;&gt;&lt;a href=&quot;#博客终于建好了&quot; class=&quot;headerlink&quot; title=&quot;博客终于建好了&quot;&gt;&lt;/a&gt;博客终于建好了&lt;/h3&gt;&lt;h3 id=&quot;非常开心，你是我的博客的第一个浏览者&quot;&gt;&lt;a href=&quot;#非常开心，你是我的博客的第一个浏览者&quot; class=&quot;headerlink&quot; title=&quot;非常开心，你是我的博客的第一个浏览者&quot;&gt;&lt;/a&gt;非常开心，你是我的博客的第一个浏览者&lt;/h3&gt;&lt;p&gt;当然，作为第一个浏览者，我也要给你写些东西吧，开业大酬宾。&lt;br&gt;我想了好久，不知道写啥。&lt;br&gt;不过在我的不懈努力下，还是想到了。&lt;br&gt;嘻嘻(●’◡’●)&lt;/p&gt;
    
    </summary>
    
    
      <category term="叶子" scheme="http://wangyibo.top/tags/%E5%8F%B6%E5%AD%90/"/>
    
  </entry>
  
</feed>
