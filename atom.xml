<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>叶</title>
  
  <subtitle>叶子( •̀ ω •́ )y</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-23T17:55:18.206Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wangyibo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>楚门的世界</title>
    <link href="http://yoursite.com/2018/05/24/%E6%A5%9A%E9%97%A8%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://yoursite.com/2018/05/24/楚门的世界/</id>
    <published>2018-05-23T16:39:17.000Z</published>
    <updated>2018-05-23T17:55:18.206Z</updated>
    
    <content type="html"><![CDATA[<p><strong>In case I don’t see you, good morning, good afternoon and good night.</strong></p><p><img src="/assets/movie/trumen.jpg" alt="">  </p><a id="more"></a> <p>这是我在看《楚门的世界》中印象最深的一句话，在影片一开头，楚门便对邻居说了这句话，在影片的结尾，楚门对者屏幕前的所有观看者，说出了这句话。<br>此话在影片开头，有一种很开心见到你，祝你一切安好，在结尾我感觉到，我的演出到此结束，我要去追寻我所向往的，当然祝你在见不到我的日子里，早安，午安，晚安。  </p><p>楚门在影片中是一个肥皂剧的主角，然而他并不知道，自己的一举一动，都被播出，被17亿人所观看，并且在他身边的人都是演员，而他就这样在一个非常巨大的摄影棚中生活了30年。<br>最终他发现了，周围的一切，妻子在与他亲吻的照片上，叠了指头；妻子会时不时的开始念广告词；街上的行人，绕着街道转着圈圈；他想要逃离这里，但受到的重重阻碍，他想去斐济，去见那个女生，那个他忘不了的女生，那个告诉他周围一切都是虚假的女生哪里去。<br><img src="/assets/movie/trumen2.jpg" alt="">  </p><p>他克服了怕海的缺限，乘着小船逃离，当然过程也是艰难的，这部肥皂剧的导演竭尽全力的去阻止他，甚至想把他杀死，但他不惧，将自己与船绑在一起。<br><img src="/assets/movie/trumen3.jpg" alt=""><br><img src="/assets/movie/trumen4.jpg" alt=""></p><p>最终他战胜了巨大的风浪走到了，这个世界的尽头，他摸到的了这个世界的边界，走上了台阶打开了门。</p><blockquote><p>TRUMAN:Who are you?</p><p>TRUMAN:And who am I?</p><p>CHRISTOF:I am the creatorof a television show that gives hope and joy and inspiration to millions.</p><p>CHRISTOF: You’re the star.</p><p>TRUMAN:Was nothing real?</p><p>CHRISTOF:YOU were real. That’s what made you so good to watch. Listen to me, Truman. There’s no more truth out there than there is in the world I created for you. Same lies. The same deceit. But in my world, you have nothing to fear. I know you better than you know yourself.</p><p>TRUMAN:You never had a camera in my head!</p><p>CHRISTOF:You’re afraid. That’s why you can’t leave. It’s okay, Truman. I understand. I have been watching you your whole life. I was watching when you were born. I was watching when you took your first step. I watched you on your first day of school. heh heh. The episode when you lost your first tooth. heh heh heh. You can’t leave, Truman. You belong here…With me. Talk to me. Say something. ‘ell, say something, goddamnit! You’re on television! You’re live to the whole world!</p><p>TRUMAN:In case I don’t see ya’, good afternoon, good evening and goodnight. Hahaha! Yeah!  </p></blockquote><p><img src="/assets/movie/trumen.jpg" alt=""><br>这是他们最后的对话，楚门在说完最后一句话后，鞠躬，谢幕，走向了另一个世界。  </p><p>我知道，我所生活的世界，存在着谎言，欺骗，在这个世界，我并不是一直是安全的，我需要考虑种种状况，但这个世界有我向往的<strong>一些真实</strong>，有人真心爱我，有人真心关心我，我也有真心所爱的人。  </p><p>可以为了理想去奋斗，最后光彩的谢幕。对这个世界说上一句：<strong>In case I don’t see you,good morning，good afternoon and good night.</strong>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;In case I don’t see you, good morning, good afternoon and good night.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/movie/trumen.jpg&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="影评" scheme="http://yoursite.com/tags/%E5%BD%B1%E8%AF%84/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://yoursite.com/2018/05/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/05/20/操作系统/</id>
    <published>2018-05-20T02:13:13.000Z</published>
    <updated>2018-05-27T14:50:13.266Z</updated>
    
    <content type="html"><![CDATA[<p>上一次对<strong>面向对象设计与分析</strong>进行了总结，没有采用<strong>思维导图</strong>的方式，此次对计算机操作系统的总结采用思维导图的方式，来进行比较那种方式更好同时，也算是复习啦。<br><a id="more"></a>  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/assets/study/OS1.jpg" alt="">  </p><hr><p><img src="/assets/study/OS2.jpg" alt="">  </p><hr><p><img src="/assets/study/OS_io.jpg" alt=""> </p><hr><p><img src="/assets/study/OS_file.jpg" alt=""> </p><hr><p><img src="/assets/study/OS_disk.jpg" alt=""> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一次对&lt;strong&gt;面向对象设计与分析&lt;/strong&gt;进行了总结，没有采用&lt;strong&gt;思维导图&lt;/strong&gt;的方式，此次对计算机操作系统的总结采用思维导图的方式，来进行比较那种方式更好同时，也算是复习啦。&lt;br&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA_String类</title>
    <link href="http://yoursite.com/2018/05/04/JAVA-String%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/05/04/JAVA-String类/</id>
    <published>2018-05-03T16:44:15.000Z</published>
    <updated>2018-05-03T17:36:34.242Z</updated>
    
    <content type="html"><![CDATA[<p>在程序设计中经常会设计处理和<strong>字符串</strong>有关的算法，而java中提供了专门用来处理字符序列的<strong>String类</strong>。  </p><p>一下就介绍一下java中的String类。 </p><a id="more"></a><p>String类，位于<strong>java.lang</strong>包中。<br>String类被定义为<strong>final类</strong> ，故不可以有子类。  </p><p>1.常量对象<br>    用双引号括起来的字符序列。<br>    String常量也是<strong>对象</strong><br>    如”你好”，”12”<br>    Java把用户程序中的String常量放入<strong>常量池</strong>，常量池中的数据在程序运行期间不能改变。 </p><p>2.String对象<br>    String类声明创建对象。<br>    如：</p><pre><code>String s = new String(&quot;cool&quot;);  String t = new String(&quot;cool&quot;);**注意**  s == t 结果是false。  s 和 t 是不同的引用，尽管实体相同但是会出现上面的情况。  同时用户是无法输出String对象的引用的。system.out.println(s); 输出的是cool。</code></pre><p>3.引用String常量  </p><pre><code>String s1,s2;  s1 = &quot;hi&quot;;  s2 = &quot;hi&quot;;  s1 == s2 返回时true。 实际上时对常量对象的引用，可以这样理解，&quot;hi&quot;本来自己有自己的专属名字，但别人不知道，他也不愿告诉别人，于是就给他起个别名，相当与它的名字，故s1 和 s2都代表它的名字，都指向它之个人。故s1 == s2 是true。</code></pre><p>String类的构造  </p><pre><code>String s = new String(&quot;&quot;);String t = new String(String s);String s = new string(char a[]);String s = new string(char a[], int b, ...);</code></pre><p>字符串的并置：  +</p><p>String类的常用方法：  </p><blockquote><p>public int lenth()<br>public boolean equals(String s)<br>public int compareTo(String s)<br>public boolean startsWith(String s)<br>public boolean endsWith(String s)<br>public boolean contains(String s)<br>public int indexOf(String s)   lastIndexOf(String s)<br>public String substring(int startpoint)<br>public String substring(int start, int end)  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在程序设计中经常会设计处理和&lt;strong&gt;字符串&lt;/strong&gt;有关的算法，而java中提供了专门用来处理字符序列的&lt;strong&gt;String类&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;一下就介绍一下java中的String类。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>linux进程</title>
    <link href="http://yoursite.com/2018/05/03/linux%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/03/linux进程/</id>
    <published>2018-05-03T14:11:26.000Z</published>
    <updated>2018-05-03T15:37:22.779Z</updated>
    
    <content type="html"><![CDATA[<p>嗯 在进程这一块的Linux，我总觉得很难，故写个总结，来加深我的理解。<br><strong>Linux下c语言编程实现</strong><br><a id="more"></a></p><p>首先：<br>什么是进程：正在执行的程序。<br>Linux 是多任务操作系统，允许多个用户使用计算机系统，多个进程<strong>并发</strong>执行。<br>Linux 环境下启动进程两种途径： <strong>手动</strong>启动和<strong>调度</strong>启动。  </p><p>一些命令：  </p><blockquote><p>ps  查看系统中的进程<br>top  动态显示系统中的进程<br>nice  按用户指定优先级运行<br>renice  改变正在运行进程的优先级<br>kill  中止进程（包括后台进程）<br>crontab  用于安装，删除或者列出用于驱动cron后台任务<br>bg  将挂起的进程放到后台<br>fg  把后台进程放到前台  </p></blockquote><p>现在了解一下<strong>进程控制</strong>吧：<br>Linux环境下创建进程时，系统会分配一个唯一的数值给每个进程，即<strong>进程标识符</strong>。<br><strong>进程号PID</strong>和<strong>父进程号PPID</strong> &nbsp; 获取PID和PPID的系统调用时 <strong>getpid</strong>和<strong>getppid</strong>函数。  </p><p><strong><em>未完待续</em></strong>  </p><p><br><br>了解一下<strong>进程通信</strong>吧：<br>一些通信方式：</p><pre><code>信号    管道  命名管道  消息队列  共享存储  信号量  套接字  </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯 在进程这一块的Linux，我总觉得很难，故写个总结，来加深我的理解。&lt;br&gt;&lt;strong&gt;Linux下c语言编程实现&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="进程" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>OOAD总结</title>
    <link href="http://yoursite.com/2018/05/02/OOAD%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/05/02/OOAD总结/</id>
    <published>2018-05-02T09:09:10.000Z</published>
    <updated>2018-05-05T13:15:14.444Z</updated>
    
    <content type="html"><![CDATA[<hr><p>先简要的了解一下什么是面向对象：把一切都看成是对象。</p><a id="more"></a><h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><p><br><br><br><br><strong>基本思想：运用对象，类，继承，聚合，关联，消息和封装（泛化）等概念和原则来构造软件的开发系统。</strong></p><ol><li>客观世界中的事物<strong>都是对象</strong>，对象之间存在一定关系。  </li><li>用对象的<strong>属性</strong>表示事物的数据特征，对象的<strong>操作</strong>表示事物的行为特征。  </li><li>对象把属性和操作结合在一起，成为不可分的独立实体，对外<strong>屏蔽</strong>具体细节。</li><li>通过<strong>抽象</strong>对事物进行分类，类是致谢对象的抽象描述，每个对象都是类的一个实例  </li><li>复杂的对象可以用简单的对象作为<strong>构成</strong>部分。</li><li>特殊类<strong>继承</strong>一般类的属性。</li><li>对象之间通过<strong>消息</strong>将进行通信，以实现对象之间的动态的联系。</li><li>通过<strong>关联</strong>表达类之间的静态关系。  </li></ol><p><br><br><br><br><strong>基本原则：抽象，分类，封装，消息通信，多态性，行为分析和复杂性控制</strong></p><ol><li><strong>抽象：</strong>从事物中舍弃个别的，非本质的特征，而抽取共同的，本质特征的思维方式。<ol><li>过程抽象：形成操作；数据抽象：把数据类型和施加在其上的操作结合在一起形成一种新的数据类型。（类和栈就是数据抽象）。  </li><li>对象是对现实世界中事物的抽象，类是对对象的抽象，一般类是对特殊类的抽象。    </li><li>面向对象的不同开发阶段需要进行不同的抽象。<br><br></li></ol></li><li><strong>分类：</strong>按照某种原则划分事物的区别，有助于认识复杂的世界。<br><br></li><li><strong>封装：</strong><ol><li>把描述一个事物的性质和行为结合在一起，对外形成该事物的一个界限。</li><li>信息屏蔽，外界不能直接存取对象的内部信息（属性），隐藏内部操作，外界也不用知道对外操作的具体细节。<br><br></li></ol></li><li><strong>消息通信：</strong>对象之间只能通过消息进行通信。又封装原则引起。<br><br></li><li><strong>多态性：</strong>一般类和特殊类可以有相同格式的属性和操作，但这些属性和操作具有不同的含义，即不同的数据类型或表现不同的行为。函数重载；运算符重载。<br><br></li><li><strong>行为分析：</strong>通过状态图，交互图进行对象行为分析。<br><br></li><li><strong>复杂性控制：</strong>引入了包的概念。</li></ol><p><br><br><br><br><strong>主要优点：</strong></p><ol><li>从认识论的角度，改变了开发软件的<strong>方式</strong>。</li><li>使得从<strong>客观世界</strong>到<strong>计算机的语言</strong>鸿沟变窄。</li><li>使得<strong>分析</strong>与<strong>设计</strong>之间的鸿沟变窄。</li><li>有助于软件的<strong>维护与复用</strong>。提高了对象的内聚性，减少了与其他对象的耦合。</li><li>有助于提高软件<strong>质量和生产率</strong>。</li></ol><p><br><br><br><br><strong>统一建模语言UML：</strong><br>只是一种建模语言，而不是建模方法；<br>UML独立于开发过程，可以适用于不同的开发过程。<br>UML2.4规范由四个部分组成：</p><ol><li><strong>基础结构</strong>：定义建模语言的核心构造物</li><li><strong>上层结构</strong>：定义建模语言——UML</li><li><strong>对象约束语言</strong>：精确的方式描述基础结构，上层结构及用户建立模型中的表达式和约束    </li><li><strong>图交换</strong>：规定了如何定义用于数据交换的XML文件的格式<br>UML2.4支持的模型图在逻辑上分为：<strong>结构图</strong>（静态方面）和<strong>行为图</strong>（动态方面）  </li></ol><hr><hr><hr><h2 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h2><p>运用面向对象的方法进行系统分析。<br><br><br><br><br><strong>面临的主要问题：</strong></p><ol><li>问题域和系统责任：<ol><li><strong>问题域：</strong>被开发系统的应用领域，即在现实世界中这个系统所涉及的业务范围。</li><li><strong>系统责任：</strong> 被开发系统应具有的职能。</li></ol></li><li>交流问题</li><li>需求的不断变化</li><li>软件复用的要求<br><br><br><br></li></ol><p><strong>综述</strong></p><p>系统分析：研究问题域，产生一个满足用户需求的系统分析模型。<br>面向对象的软件建模规范——概念与表示法</p><ol><li><strong>概念与表示法</strong><br><br></li><li><strong>OOA模型：</strong>面向对象分析所建立的系统模型，表达了OOA阶段所认识到的系统成分及彼此间的关系。<ol><li>需求模型：用况图</li><li>基本模型： 类图<ol><li>对象层：给出系统中所有反映问题域与系统责任的对象。<strong>类是构成系统的基本单位</strong>。</li><li>特征层：给出每一个类的<strong>内部特征</strong>，给出你每个类的属性和操作。</li><li>关系层：给出各个类之间的<strong>关系</strong>。</li></ol></li><li>辅助模型： 顺序图，活动图，状态图，包图。</li><li>模型规约：文档，进行详说明。  </li></ol></li></ol><p>可以建立对象图，作为类图的补充。</p><p><br></p><hr><hr><hr><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="用况图"><a href="#用况图" class="headerlink" title="用况图"></a>用况图</h3><p> <strong>系统边界：</strong>系统边界是一个系统所包含的所有系统成分与系统以外的事物的分界线。<br> <strong>参与者：</strong>一组在功能上密切相关的角色，当一个事物与系统交互时，该事物要扮演这样的角色。 <strong>参与者不是系统的一部分，他们位于系统之外，是在系统之外的与系统交互的任何事物。</strong></p><p><em>识别参与者</em>:</p><ol><li><strong>人员</strong>：直接使用系统的人员中发现参与者。</li><li><strong>外部系统</strong>：所有与本系统交互的外部系统都是参与者。</li><li><strong>设备</strong>：与系统相连，像系统提供外界信息；也可能系统向设备提供信息，设备在系统的控制下运行（不包括监视器，键盘，鼠标这样的标准用户接口设别）。<br><strong>用况：</strong>一个用况是描述系统的一项功能的一组动作序列，这样的动作序列表示参与者与系统的交互，系统执行该动作序列<strong>要为参与者产生结果</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意：</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 用况是一种<strong>类型</strong>，它是要被<strong>实例化执行</strong>的。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 用况描述中的一个动作应该<strong>描述参与者</strong>或<strong>系统要完成的一个交互步骤</strong>。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 执行用况的一个动作序列要为参与者<strong>产生可观察的结果</strong>。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 保证用况所对应的<strong>功能完整</strong>，用况不分层，不能说上层的用况是由下层较小的用况组成。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 用况<strong>不说明</strong>具体<strong>细节</strong>。  </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>关系：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与参与者之间：<strong>关联</strong> 是参与者与用况的唯一关系。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用况间的关系：<strong>包含</strong>， <strong>扩展</strong>，<strong>继承</strong>。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>捕获用况：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 从<strong>参与者</strong>的角度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 从<strong>系统功能</strong>的角度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 利用<strong>场景</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>用况模板</strong>  </p><p> <strong>用况图</strong>  </p><p>  定义： 是由<strong>参与者</strong>，<strong>用况</strong>以及这些元素之间的的<strong>关系</strong>组成的图。<br>  检查与调整：<br>  每个<strong>参与者至少与一个用况相关联</strong>。<br>  参与者之间可以有<strong>继承</strong>关系<br>  不能按照人机界面建立用况，<strong>界面不是用况，用况也不是界面</strong>。  </p><hr><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p> 类图描述了系统中各类对象以及他们之间的各种关系。  </p><h4 id="概念与表示法"><a href="#概念与表示法" class="headerlink" title="概念与表示法"></a>概念与表示法</h4><p> <strong>对象：</strong> 是具有明确的语义边界并封装了状态和行为的实体，由一组属性和作用在这组属性上的一组操作构成，他是构成软件系统的<strong>基本单位</strong>。<br> <strong>类：</strong>是具有<strong>相同属性</strong>和<strong>操作</strong>的一组对象的统一抽象描述，对象是类的实例。  </p><p> <strong>对象的审查和筛选</strong></p><ul><li>舍弃无用对象：1.通过<strong>属性</strong>判断；2.通过<strong>操作</strong>判断。  </li><li>精简对象：只有<strong>一个</strong>属性或操作的对象。 </li><li>推迟到<strong>OOD</strong>考虑的对象。<br><strong>抽象出类并进行调整</strong><br><strong>主动对象及主动行为：</strong></li><li>主动对象：具有<strong>主动行为</strong>的对象，在设计阶段是拥有线程或进程并启动<strong>控制活动</strong>的对象  。</li><li><p>主动类：是其实例为主动对象的类。    </p><p><strong>建立类的对象层</strong> </p></li></ul><h4 id="属性和操作"><a href="#属性和操作" class="headerlink" title="属性和操作"></a>属性和操作</h4><ol><li>属性： 描述对象性质的<strong>数据项</strong>。   （实例属性， 类属性）<br>格式： [可见性] 属性名[：类型] [=初始值]    </li><li>操作： 类的对象被要求提供的<strong>服务的规约</strong>。<br>格式：[可见性] 操作名 [ (参数列表) ] [：返回类型] （实例操作，类操作）<br>系统行为， 对象行为（算法简单，算法复杂）。  <blockquote><p>对象的审查：是否有用，是否高内聚。 </p></blockquote></li></ol><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><ol><li><strong>继承:</strong>   <ul><li>类A的全部对象都是类B的对象，且类B中存在不属于类A的对象，则A是B的特殊类，B是A的一般类，A与B之间的关系叫继承。</li><li>类A具有类B的特征，且还具有自己的一些特征，则A叫做B的特殊类，B是A的一般类，A与B之间的关系叫继承。  </li></ul></li></ol><blockquote><p>非对称性<br>传递性</p></blockquote><blockquote><p>多继承<br>单继承  </p></blockquote><blockquote><p>表示法  </p></blockquote><ol start="2"><li><strong>关联</strong><br>关联是一个或一组类的对象集合的笛卡尔积上的一个子集合（即一个由对象构成的集合），这种类间的关系用于刻画同种或异种类别事物间的关系。<br><strong>一元关联</strong>：连接到自身的关联。<br><strong>链</strong>：关联的一个实例（即一个对象偶对），用于刻画具体事物间的关系。 若在两个对象间建立了链，一个对象就可以直接访问另一个对象。在对象生命周期内，对象之间的链是在某段时间内存在的。<br><strong>多重性</strong><br><strong>关联角色</strong><br><strong>关联类</strong>：关联类是兼有关联和类的双重特征的建模元素，既可以把关联类看作是具有类的关联特征的关联，也可以看作是具有关联特征的类。<br>因其超过了当前面向对象编程语言的概念范围，可以通过<strong>增设类</strong>把关联类表示为普通类。<br><strong>N元关联</strong>：三个或三个以上的关联。<br><strong>限定符</strong>  </li></ol><ol start="3"><li><p><strong>聚合</strong><br>客观世界中，事物之间的整体-部分关系是大量存在的。运用聚合可清晰的表达事物之间的整体-部分关系。减少认识事物的复杂性。<br>可以理解为：一个类的定义引用了<strong>另一个类</strong>定义。<br>作为<strong>整体</strong>的类称为 聚集 ；作为<strong>部分</strong>的类称为 成分  </p><blockquote><p>非对称性<br>传递性</p></blockquote><p><strong>组合</strong>是聚合的一种形式，一个部分类的对象在一个时刻必须最多属于一个整体类的对象，且整体类的对象管理它的部分类的对象。<br>聚合表示成一条一端带有一个菱形的线段，组合菱形是实心的。  </p></li></ol><ol start="4"><li><p><strong>依赖</strong><br>表明一个元素（源元素）的定义或实现<strong>依赖</strong>另一个元素的定义或实现，即对被依赖的元素的改变要改变该关系中的源元素，其中的元素可以是单个的模型元素，也可以是集合类型的模型元素。<br>在用况图中的包含（include） 扩展（extend） 就是依赖。<br>把依赖表示为两个建模元素之间的虚线。箭头尾部元素依赖箭头头部元素    </p></li><li><p><strong>接口</strong><br>接口声明了一组操作，用以刻画模型元素对外提供的服务或者它所需要的外部服务。这样的元素可以是类，以刻是构件和子系统。<br>一个类可实现一个或多个接口，把这样的接口称为类的<strong>供接口</strong>，一个或多个类可使用一个或多个接口，把这样的接口称为<strong>需接口</strong>。  </p></li></ol><h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p>顺序图是一种详细描述<strong>对象之间</strong>以及<strong>对象</strong>与<strong>参与者</strong>之间交互的图，它由一组相互协作的对象或参与者实例以及它们之间的消息组成，强调<strong>消息之间的顺序</strong>。<br>组成：<br>对象生命线：表示对象在一段时间内的存在。<br>执行规约：是一个对象执行一个操作的时期。在执行该操作时可能还调用了本对象或者其他对象中的操作。<br>消息：是对象之间的通信规格说明，这样的通信用于传输将发生的活动所需要的信息，既包含了控制（如调用）的规格说明，也包含了使用的数据之间的规格说明。<br>&nbsp;&nbsp;同步消息：一般用于普通的过程调用。<br>&nbsp;&nbsp;异步消息：用于表示异步通信，即发送者发出信号后，立即执行下一步操作，不进行等待。<br>信号： 是对象之间的异步通信的规格说明。  信号名 （参数名：类型表达式，参数名：类型表达式）  </p><p>顺序图中的结构化控制：<br>sd 标签<br>可选执行 opt<br>条件执行 alt<br>并行执行 par<br>循环执行 loop<br>引用 ref </p><h3 id="通信图"><a href="#通信图" class="headerlink" title="通信图"></a>通信图</h3><p>强调发送和接受消息的对象组织结构的图，用以展示围绕对象以及他们之间的的连接器而组织的交互。  </p><h3 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h3><p>描述动作，动作的执行次序以及动作的输入与输出的图，由动作节点和边构成。  </p><p>动作：可执行的基本功能单元，描述状态转换或活动，是原子的和即时的。<br>活动：有一组相互协作的动作构成的行为单元。活动在执行中可以被事件中断。<br>控制流；当动作结束时，马上进入下一个的动作流程。可以并发。<br>对象流：在控制流中可含有对象，用以描述动作间输入与输出的数据。<br>泳道：在对业务过程建模时，可以把动作分成组，每组由特定的履行者来执行。每个组分别称为一个泳道。  </p><h3 id="状态机图"><a href="#状态机图" class="headerlink" title="状态机图"></a>状态机图</h3><p>描述了一个对象在其生命周期内因响应事件所经历的状态序列以及对这些事件做出的反应。<br>状态机图主要由状态和状态间的转移构成的。  </p><p>事件：信号事件，调用事件，时间事件，改变事件。  事件名（参数名：类型表达式，参数名：类型表达式）<br>状态：对象在其生命周期中满足特定的条件，进行特定的活动或等待特定时间的状况。  初始状态，终止状态都是<strong>伪状态</strong>。<br>转移：状态间的转移，状态内的转移。  事件触发器[(参数名：类型表达式…)] [监护条件] / [动作表达式]<br>&nbsp;&nbsp;状态内的转移：entry/进入动作表达式；exit/退出动作表达式；do/活动<br>&nbsp;&nbsp;状态间的转移：<br>正交状态：具有多个区域的组合状态； 非正交状态：只有一个区域的组合状态。  </p><h3 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h3><p>描述模型元素分组以及分组之间依赖的图，其中要用到的包时对模型元素进行分组的机制。  ::<br>一个包形成了一个命名空间。一个包的语境中同一种元素的名字必须唯一，在一个包中不同种类的模型元素可以有相同的名字。  </p><p>包间的关系：<br>拥有<br>引入依赖 箭头指向提供者包。 &lt;&lt; import &gt;&gt;  相当于把提供者包的内容附加到客户包的<strong>公共命名空间中</strong><br>访问依赖 箭头指向提供者包。 &lt;&lt; access &gt;&gt;  相当于把提供者包的内容附加到客户包的<strong>私有命名空间中</strong><br>继承   </p><hr><hr><hr><h2 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h2><p>OOD模型：<br>核心部分：问题域部分（OOA的结果作为输出）<br>外围部分：人机交互部分，控制驱动部分，数据管理部分，构建及部署部分（最后进行）。  </p><h3 id="问题域部分的设计："><a href="#问题域部分的设计：" class="headerlink" title="问题域部分的设计："></a>问题域部分的设计：</h3><p>复用类  {复用} 标记<br>增加一般类以建立公共协议<br>提高性能  </p><p><strong>按编程语言调整继承</strong><br>多继承的调整：1.采用聚合把多继承换位单继承；2.采用压平的方式<br>取消继承<br>对多态性的调整  </p><p><strong>转化复杂关联并决定关联的实现方式</strong><br>转化复杂关联：1.把关联类和N元关联转化为二元关联；2.把多对多关联转化为一对多关联。<br>决定关联的实现方式：1.聚合；2关联  c++指针变量， java引用变量  </p><p><strong>调整与完善属性</strong><br>语法： [可见性] 属性名[‘:’类型] [‘=’ 初始值]<br>对需要明确但在OOA还没有确定可见性的属性进行标记。按照OO的信息隐蔽原则，要尽可能地保持数据私有化。  </p><p><strong>构造及优化算法</strong><br>操作：[可见性] 操作名[(参数列表)] [: 返回类型]<br>完善操作的定义，设计算法，异常处理。  </p><p><strong>决定对象间的可访问性</strong><br>类A的对象和类B的对象之间存在者链<br>类B的对象变量作为类A的一个操作参数<br>类B的对象变量在类A的一个操作方法中被声明为局部的<br>类B的对象时全局可见的  </p><p><strong>定义对象实例</strong>  </p><h3 id="人机交互部分的设计："><a href="#人机交互部分的设计：" class="headerlink" title="人机交互部分的设计："></a>人机交互部分的设计：</h3><p>突出人如何命令系统以及系统如何向用户提交信息。<br>从<strong>用况</strong>分析人机交互<br>设计输入，设计输出<br><strong>命令的组织</strong>：设计用户使用系统的命令以及对命令的组织<br>&nbsp;&nbsp;1.分解；2.组合（形成层次结构）<br>&nbsp;&nbsp;基本命令：使用一项独立的系统功能命令；<br>&nbsp;&nbsp;命令步：执行一条基本命令的交互过程中所包含的具体输入步骤。<br>&nbsp;&nbsp;高层命令：如果一条命令实在另一条命令的引导下被选用的，则后者称作前者的高层命令。<br>&nbsp;&nbsp;命令步直接按可能存在三种输出信息结构：1.反馈信息（如进度条）；2.处理结果（当前命令的执行结果）；3.提示信息<br>&nbsp;&nbsp;建立命令树时策略：1.用最频繁的命令放在方便处；2.在命令中发现整体-部分模式；3.7+-2原则，命令层次深度尽量小。<br><strong>用OO概念表达所有的界面成分</strong><br><strong>衔接界面模型和问题域模型</strong><br><strong>人机交互部分的设计准则</strong><br>&nbsp;&nbsp;1.易学，易用。操作方便<br>&nbsp;&nbsp;2.尽量保持一致<br>&nbsp;&nbsp;3.及时提供有意义的反馈<br>&nbsp;&nbsp;4.使用户的注意力集中在当前的任务上而不是界面上<br>&nbsp;&nbsp;5.减少用户记忆<br>&nbsp;&nbsp;6.具有语境敏感帮助功能<br>&nbsp;&nbsp;7.减少重复的输入和操作<br>&nbsp;&nbsp;8.防止灾难性的错误<br>&nbsp;&nbsp;9.其他  </p><h3 id="控制驱动部分的设计"><a href="#控制驱动部分的设计" class="headerlink" title="控制驱动部分的设计"></a>控制驱动部分的设计</h3><p>这部分由系统中<strong>全部的主动类</strong>构成<br>每个主动类所创建的一个主动对象是系统中一个控制流的驱动者<br><strong>控制流</strong>：进程和线程的统称<br>&nbsp;&nbsp;进程时处理机的分配单位，也是存储空间，设备等资源的分配单位；线程只是处理机的分配单位。<br>&nbsp;&nbsp;控制流的创建：当创建了一个主动对象时<br>&nbsp;&nbsp;控制流的撤销：当撤销主动对象时<br><strong>设置控制驱动部分</strong>  控制流的表示：&lt;&lt; progress &gt;&gt; 或 &lt;&lt; thread &gt;&gt;<br><strong>进程和线程间的通信</strong>1.操作调用；2.邮箱；3.共享存储器；4.远程过程调用；（1.2.3：线程）（2.3.4：进程）<br>&nbsp;&nbsp;控制流间的同步：为了<strong>协调</strong>并发控制流的执行，以<strong>防止</strong>多控制流同时读写共享资源以及防止控制流的<strong>死锁</strong>和控制流的<strong>饿死</strong><br>&nbsp;&nbsp;实现：把所操作的对象作为临界资源，然后加以同步。 1.顺序的（sequential） 2.受监护的（guarded） 3.并发的（concurrent）<br>&nbsp;&nbsp;进一步地，对于多个需要相互交互的控制流，可以考虑使用哦个一个或几个控制流，起协调者的作用  </p><h3 id="数据管理部分的设计"><a href="#数据管理部分的设计" class="headerlink" title="数据管理部分的设计"></a>数据管理部分的设计</h3><p>需要长期存储的对象，称为<strong>持久对象</strong>，其属于的类属于<strong>持久类</strong><br>数据管理部分负责<strong>存储和检索持久对象</strong>，<strong>封装</strong>对这些对象的<strong>查找和存储机制</strong>，以隔离数据管理方案对其他部分的影响，特别是对<strong>问题域</strong>部分的影响   </p><p>数据库：是<strong>长期</strong>存在于计算机内，有组织，可共享的数据<strong>集合</strong><br>数据库管理系统：用于建立，使用和维护数据库的<strong>软件</strong>，它对数据库进行统一的管理和控制，以保证数据库的<strong>完整性和安全性</strong><br>&nbsp;&nbsp;关系数据库<br>&nbsp;&nbsp;面向对象数据库  </p><h3 id="构件及部署部分的设计"><a href="#构件及部署部分的设计" class="headerlink" title="构件及部署部分的设计"></a>构件及部署部分的设计</h3><p><strong>构建设计</strong> 构建图是描述<strong>构件</strong>，<strong>构件的内部结构</strong>和<strong>构建之间</strong>关系的图<br>&nbsp;&nbsp;构件：是系统中可<strong>替换和复用</strong>的模块化部分，它<strong>封装</strong>了自己的内容，利用<strong>供接口和需接口</strong>定义自身的行为；起类型的作用. 构件内部的一个部件：另一个构件，端口，类<br>&nbsp;&nbsp;&nbsp;&nbsp;表示：带有&lt;<component>&gt;的矩形，右上角可放一个图标<br>&nbsp;&nbsp;构件的接口：<br>&nbsp;&nbsp;&nbsp;&nbsp;构件的供接口：构件实现的接口； 构件的需接口：构建需要使用的接口，即构件向其他构件请求服务时要遵循的接口；<br>&nbsp;&nbsp;&nbsp;&nbsp;一个构件可以实现多个接口，也可以请求多个接口。一个接口可以由多个不同构件实现<br>&nbsp;&nbsp;&nbsp;&nbsp;三种表示：1.简略的图符形式；2.扩展方式；3.分栏矩形<br>&nbsp;&nbsp;构建的端口：描述了在构件与它的环境之间以及在构件与它的内部部件之间的一个显示的交互点，即端口时一个封装构件的显示的对外窗口，所有进出构件的消息都要进过端口。<br>&nbsp;&nbsp;&nbsp;&nbsp;表示：一个挎在构件边上的小方块<br>&nbsp;&nbsp;连接件：装配连接件；委托连接件<br>&nbsp;&nbsp;构件的内部结构：可以在构件的矩形图符上加一个分栏中来列出其内部组成元素（如接口，部件，连接件）：&lt;<realization>&gt;构件内部成分，&lt;<artifact>&gt;物理实现体<br>&nbsp;&nbsp;对构件的行为建模<br>&nbsp;&nbsp;对构件的实现建模  制品：工作产业制品（源代码等），部署制品（exe文件等）。&nbsp;&nbsp;类型级，实例级  &lt;&lt; manifest &gt;&gt;承载（一种依赖关系）<br>&nbsp;&nbsp;部署设计 <strong>节点</strong>是<strong>制品</strong>可部署并执行在其上的<strong>计算资源</strong>，并能够通过通信路径互联.通常把节点看成是一个可以在其上部署可执行制品的运行环境  表示：立方体<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; deploy &gt;&gt;</artifact></realization></component></p><hr><hr><hr><h2 id="若干设计模式"><a href="#若干设计模式" class="headerlink" title="若干设计模式"></a>若干设计模式</h2><p>设计模式分类：<br>1.结构型：通过用<strong>接口</strong>将实现与抽象联系起来的方式把已由对象<strong>组合</strong>起来进行建模<br>2.行为型：通过对变化进行<strong>封装</strong>使得所建立的模型可以提供<strong>灵活</strong>的方式<br>3.创建型：用于对<strong>创建对象</strong>的建模  </p><p>原则：<br>1.针对接口编程<br>2.优先使用组合，而不是继承<br>3.正确的使用委托<br>4.找出变化并进行封装  </p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>用于为子系统中的一组对象提供统一的接口，使得系统更易于使用。也可以说,通过<strong>量身定做</strong>来建立提供所需功能的接口  </p><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center">外观模式</td></tr><tr><td style="text-align:center">意图</td><td style="text-align:center">通过定义所需要的接口，简化原有系统的使用方式</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:center">只使用原系统的功能部分，或以特殊方式于系统交互</td></tr><tr><td style="text-align:center">解决方案</td><td style="text-align:center">为原有系统的用户提供新的接口</td></tr><tr><td style="text-align:center">协作者</td><td style="text-align:center">系统，接口，用户</td></tr><tr><td style="text-align:center">效果</td><td style="text-align:center">简化了所需子系统的使用方法</td></tr></tbody></table><p><img src="/assets/study/waiguanmoshi.jpg" alt="">  </p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>用于将类的一个接口<strong>转化</strong>为另一个类所需的接口，以使由于<strong>接口不兼容</strong>的类能够一起协作  </p><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center">适配器模式</td></tr><tr><td style="text-align:center">意图</td><td style="text-align:center">使一个类的接口与一个结构（通常使用多态机制的继承结构）中的类的接口相匹配</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:center">一个类的操作的语义与一个结构中的类的接口相一致，但特征标记有差异</td></tr><tr><td style="text-align:center">解决方案</td><td style="text-align:center">该模式提供了起包装作用的类，以使得接口相一致</td></tr><tr><td style="text-align:center">协作者</td><td style="text-align:center">适配者，被适配者，一般类，客户</td></tr><tr><td style="text-align:center">效果</td><td style="text-align:center">使得原有类与所需结构的接口相匹配</td></tr></tbody></table><p><img src="/assets/study/shipeiqimoshi.jpg" alt="">  </p><center>外观模式与适配器模式的比较</center><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">外观模式</th><th style="text-align:center">适配器模式</th></tr></thead><tbody><tr><td style="text-align:center">按特定接口设计</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">使用多态机制</td><td style="text-align:center">否</td><td style="text-align:center">可能</td></tr><tr><td style="text-align:center">目标接口更简单</td><td style="text-align:center">是</td><td style="text-align:center">没变化</td></tr></tbody></table><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>描述怎样按需要在一组<strong>可替换的算法</strong>中选用算法，即把所定义的一些算法各自<strong>封装</strong>起来，可根据<strong>客户的需要</strong>分别使用他们。  </p><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center">策略模式</td></tr><tr><td style="text-align:center">意图</td><td style="text-align:center">根据语境使用不同的业务规则或算法</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:center">处理客户数据的算法种类可能发生变化，且要根据需要选择算法</td></tr><tr><td style="text-align:center">解决方案</td><td style="text-align:center">把对算法的选择和算法的实现相分离，并根据语境选择算法</td></tr><tr><td style="text-align:center">协作者</td><td style="text-align:center">语境，抽象策略，具体策略</td></tr><tr><td style="text-align:center">效果</td><td style="text-align:center">按需要定义算法，并可按相同的方式使用：封装了算法种类的变化性</td></tr></tbody></table><p><img src="/assets/study/celuemoshi.jpg" alt="">  </p><h3 id="观察者模式（发布-订阅模式）"><a href="#观察者模式（发布-订阅模式）" class="headerlink" title="观察者模式（发布-订阅模式）"></a>观察者模式（发布-订阅模式）</h3><p>用于定义对象间的<strong>一对多的依赖关系</strong>，当一个对象发生变化并对外发布消息时，所有依赖它的对象都将<strong>得到通知并可进行更新</strong>  </p><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center">观察者模式</td></tr><tr><td style="text-align:center">意图</td><td style="text-align:center">用于定义对象间的一对多的依赖关系，当一个对象发生变化并对外发布消息时，所有依赖它的对象都将得到通知并可进行更新</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:center">当一个对象发生变化并对外发布消息时，需要向对象数目不定的对象集发出通知</td></tr><tr><td style="text-align:center">解决方案</td><td style="text-align:center">观察者将检测事件的责任委托给一个专门的对象</td></tr><tr><td style="text-align:center">协作者</td><td style="text-align:center">事件发布者，具体事件发布者，观察者，具体观察者</td></tr><tr><td style="text-align:center">效果</td><td style="text-align:center">如果某些观察者只对一部分事件感兴趣，那么它们可只订阅这些事件。发布者和观察者均可独立变化，只是二者中已规定的操作除外</td></tr></tbody></table><p><img src="/assets/study/guanchazhemoshi.png" alt="">  </p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>在<strong>一般类</strong>中定义一个用于创建对象的<strong>接口</strong>，让<strong>特殊类</strong>的对象决定实例化哪一个类。该模式把创建对象的工作推给特殊类的对象  </p><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center">工厂方法模式</td></tr><tr><td style="text-align:center">意图</td><td style="text-align:center">定义一个用于创建对象的接口的接口，让特殊类的对象创建对象，即把创建对象的工作推迟给特殊类的对象去完成</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:center">需要创建不同种类的对象，但不知道创建哪一种，而让特殊类去决策</td></tr><tr><td style="text-align:center">解决方案</td><td style="text-align:center">特殊类的对象负责创建对象</td></tr><tr><td style="text-align:center">协作者</td><td style="text-align:center">抽象产品，具体产品，抽象创建者，具体创建者</td></tr><tr><td style="text-align:center">效果</td><td style="text-align:center">通过创建的特殊类，客户可得到所需要的对象</td></tr></tbody></table><p><img src="/assets/study/gongchangfangfa.jpg" alt="">  </p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>为创建一组<strong>相关或相互依赖</strong>的对象提供一个<strong>接口</strong>，而<strong>不需要</strong>指出用于创建对象的<strong>具体类</strong>。  </p><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center">抽象工厂模式</td></tr><tr><td style="text-align:center">意图</td><td style="text-align:center">为特定的客户端提供一组对象</td></tr><tr><td style="text-align:center">问题</td><td style="text-align:center">需要实例化出一组相关对象</td></tr><tr><td style="text-align:center">解决方案</td><td style="text-align:center">提供一种方式，把创建对象的规则从使用这些对象的客户对象中提取出来，放在负责创建对象组的工厂中</td></tr><tr><td style="text-align:center">协作者</td><td style="text-align:center">客户，抽象产品，具体产品，抽象工厂，具体工厂</td></tr><tr><td style="text-align:center">效果</td><td style="text-align:center">把使用哪些对象与创建者些对象的逻辑分开</td></tr></tbody></table><p><img src="/assets/study/chouxianggongchang.jpg" alt="">  </p><hr><hr><hr><h2 id="OOD的评价准则"><a href="#OOD的评价准则" class="headerlink" title="OOD的评价准则"></a>OOD的评价准则</h2><p>耦合：描述OOD成分之间的联系的紧密程度。  考虑耦合的目的：改动一部分，对其他部分的影响应尽量地小；阅读一部分，需要查阅的其他部分也要尽量少<br>&nbsp;&nbsp;交互耦合：模型成分间通过消息的交互程度  <strong>弱</strong>耦合好<br>&nbsp;&nbsp;继承耦合：特殊类继承一般类的属性和操作的数量程度  <strong>强</strong>耦合好<br>内聚：描述一个OOD成分内所完成功能的紧密程度<br>&nbsp;&nbsp;操作内聚：若一个操作只完成一项功能，则说它是高内聚的<br>&nbsp;&nbsp;类内聚：一个类内的属性和操作应该描述类本身的责任，属性均与操作相关，而且其内的所有操作作为一个整体也是紧密相关的<br>&nbsp;&nbsp;继承内聚：继承关系要讲的通<br>复用：复用以有的软件制品，能节省软件的开发成本，提高软件的质量和生产率<br>其他评价准则：<br>&nbsp;&nbsp;清晰度好<br>&nbsp;&nbsp;继承层次深度适当<br>&nbsp;&nbsp;保持对象和类的简单性<br>&nbsp;&nbsp;所有需要的属性和操作都要被适当地的使用<br>&nbsp;&nbsp;尽量地使用与提炼设计模式<br>&nbsp;&nbsp;考虑设计易变性地最小化  </p><hr><hr><hr><h2 id="系统与模型"><a href="#系统与模型" class="headerlink" title="系统与模型"></a>系统与模型</h2><p>系统：是由为了达到特定目的而组织起来的模型元素构成的，可用从不同抽象层次和不同角度建造的模型来描述它。<br>如果一个系统较为复杂，可把它分解成一组子系统。每个子系统要完成特定的功能，有自己的应用环境，通过接口与系统交互<br>&lt;&lt; system &gt;&gt; 系统  &lt;&lt; subsystem &gt;&gt;子系统<br>对体系结构建模：<br>1.三层体系结构模式：用户界面，业务逻辑，数据管理<br>2.管道过滤型体系结构模式<br>模型：为了更好的描述事物的抽象<br>视图：是系统模型在某一侧面的投影，即它是观察或突出所被建模的系统的一个侧面（视角），其中要忽略与这以侧面无关的方面<br>五个视图，两个方面：用况视图，实现视图，进程视图，设计视图，部署视图， 静态方面，动态方面<br>&lt;&lt; trace &gt;&gt;的虚线 追踪依赖  从低层模型中的元素指向相邻高层模型中的元素<br>用带有一个三角图符或&lt;&lt; model &gt;&gt;的包图表示模型    </p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;先简要的了解一下什么是面向对象：把一切都看成是对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="UML" scheme="http://yoursite.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>你</title>
    <link href="http://yoursite.com/2018/04/29/%E4%BD%A0/"/>
    <id>http://yoursite.com/2018/04/29/你/</id>
    <published>2018-04-29T15:11:32.000Z</published>
    <updated>2018-04-30T03:24:17.557Z</updated>
    
    <content type="html"><![CDATA[<p><img src="assets/img/me.jpg" alt=""></p><h3 id="博客终于建好了"><a href="#博客终于建好了" class="headerlink" title="博客终于建好了"></a>博客终于建好了</h3><h3 id="非常开心，你是我的博客的第一个浏览者"><a href="#非常开心，你是我的博客的第一个浏览者" class="headerlink" title="非常开心，你是我的博客的第一个浏览者"></a>非常开心，你是我的博客的第一个浏览者</h3><p>当然，作为第一个浏览者，我也要给你写些东西吧，开业大酬宾。<br>我想了好久，不知道写啥。<br>不过在我的不懈努力下，还是想到了。<br>嘻嘻(●’◡’●)</p><a id="more"></a><h2 id="乐华"><a href="#乐华" class="headerlink" title="乐华"></a>乐华</h2><p><img src="/assets/blogimg/lh1.jpg" alt=""><br><br><br><img src="/assets/blogimg/lh2.jpg" alt=""><br><br><br><br><br>我记得那天我们去了好多地方。<br>在大唐芙蓉园，散了步，看见了好多拍婚纱照的人。<br>在海洋馆，看了好多小动物，当然我觉得海洋馆最多的还是小孩纸。<br>在乐华，玩了好多过山车，看了5D电影，不过你没玩跳楼机哦。<br><br></p><h2 id="做蛋糕"><a href="#做蛋糕" class="headerlink" title="做蛋糕"></a>做蛋糕</h2><p><img src="/assets/blogimg/zdg2.jpg" alt=""><br><br></p><p><img src="/assets/blogimg/zdg.jpg" alt=""><br><br><br>这是元旦。<br>一大早，去看电影，结果进不去，就在底下各种找进去的路。<br>下午去做蛋糕喽，咱么的蛋糕好可爱。<br><br></p><h2 id="西安电视塔"><a href="#西安电视塔" class="headerlink" title="西安电视塔"></a>西安电视塔</h2><p><img src="/assets/blogimg/tv.jpg" alt=""><br><br></p><p><img src="/assets/blogimg/tv2.jpg" alt=""><br><br><br>在西安电视塔的最高处，站在玻璃上。<br>我一想到你在上面不敢走动，就想笑，你真是太可爱啦。<br>在科技馆，走那个玻璃迷宫，你不停的撞。<br>夜里买了书，吃了泡馍。<br><br></p><h2 id="樱花"><a href="#樱花" class="headerlink" title="樱花"></a>樱花</h2><p><img src="/assets/blogimg/yh.jpg" alt=""><br><br></p><p><img src="/assets/blogimg/yh2.jpg" alt=""><br><br><br>樱花开了，赏花去喽。</p><p><strong>嗯 放张合照吧</strong><br><img src="/assets/blogimg/hez.jpg" alt=""><br><br></p><h2 id="全都是你啦"><a href="#全都是你啦" class="headerlink" title="全都是你啦"></a>全都是你啦</h2><p><img src="/assets/blogimg/yz.jpg" alt=""><br><img src="/assets/blogimg/yz1.jpg" alt=""><br><img src="/assets/blogimg/yz2.jpg" alt=""><br><img src="/assets/blogimg/yz3.jpg" alt=""></p><p><br></p><h2 id="嗯-是不是该抒情了"><a href="#嗯-是不是该抒情了" class="headerlink" title="嗯 是不是该抒情了"></a>嗯 是不是该抒情了</h2><p><strong>我喜欢的样子，你都有</strong></p><p align="right"> —《甜甜的》周杰伦</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;assets/img/me.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;博客终于建好了&quot;&gt;&lt;a href=&quot;#博客终于建好了&quot; class=&quot;headerlink&quot; title=&quot;博客终于建好了&quot;&gt;&lt;/a&gt;博客终于建好了&lt;/h3&gt;&lt;h3 id=&quot;非常开心，你是我的博客的第一个浏览者&quot;&gt;&lt;a href=&quot;#非常开心，你是我的博客的第一个浏览者&quot; class=&quot;headerlink&quot; title=&quot;非常开心，你是我的博客的第一个浏览者&quot;&gt;&lt;/a&gt;非常开心，你是我的博客的第一个浏览者&lt;/h3&gt;&lt;p&gt;当然，作为第一个浏览者，我也要给你写些东西吧，开业大酬宾。&lt;br&gt;我想了好久，不知道写啥。&lt;br&gt;不过在我的不懈努力下，还是想到了。&lt;br&gt;嘻嘻(●’◡’●)&lt;/p&gt;
    
    </summary>
    
    
      <category term="叶子" scheme="http://yoursite.com/tags/%E5%8F%B6%E5%AD%90/"/>
    
  </entry>
  
</feed>
